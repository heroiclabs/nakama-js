// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

import { buildFetchOptions } from './utils';
import { encode } from 'js-base64';

/** A friend of a friend. */
export interface FriendsOfFriendsListFriendOfFriend {
  // The user who referred its friend.
  referrer?: string;
  // User.
  user?: ApiUser;
}

/** A single user-role pair. */
export interface GroupUserListGroupUser {
  // Their relationship to the group.
  state?: number;
  // User.
  user?: ApiUser;
}

/** A single group-role pair. */
export interface UserGroupListUserGroup {
  // Group.
  group?: ApiGroup;
  // The user's relationship to the group.
  state?: number;
}

/** Record values to write. */
export interface WriteLeaderboardRecordRequestLeaderboardRecordWrite {
  // Optional record metadata.
  metadata?: string;
  // Operator override.
  operator?: ApiOperator;
  // The score value to submit.
  score?: string;
  // An optional secondary value.
  subscore?: string;
}

/** Record values to write. */
export interface WriteTournamentRecordRequestTournamentRecordWrite {
  // A JSON object of additional properties (optional).
  metadata?: string;
  // Operator override.
  operator?: ApiOperator;
  // The score value to submit.
  score?: string;
  // An optional secondary value.
  subscore?: string;
}

/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  // The custom id in the user's account.
  custom_id?: string;
  // The devices which belong to the user's account.
  devices?: Array<ApiAccountDevice>;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's account was disabled/banned.
  disable_time?: string;
  // The email address of the user.
  email?: string;
  // The user object.
  user?: ApiUser;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user's email was verified.
  verify_time?: string;
  // The user's wallet data.
  wallet?: string;
}

/** Send a Apple Sign In token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountApple {
  // The ID token received from Apple to validate.
  token?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface ApiAccountCustom {
  // A custom identifier.
  id?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  // A device identifier. Should be obtained by a platform-specific device API.
  id?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  // A valid RFC-5322 email address.
  email?: string;
  // A password for the user account.  Ignored with unlink operations.
  password?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebook {
  // The OAuth token received from Facebook to access their profile API.
  token?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebookInstantGame {
  //
  signed_player_info?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.

https://developer.apple.com/documentation/gamekit/gklocalplayer/1515407-generateidentityverificationsign */
export interface ApiAccountGameCenter {
  // Bundle ID (generated by GameCenter).
  bundle_id?: string;
  // Player ID (generated by GameCenter).
  player_id?: string;
  // The URL for the public encryption key.
  public_key_url?: string;
  // A random "NSString" used to compute the hash and keep it randomized.
  salt?: string;
  // The verification signature data generated.
  signature?: string;
  // Time since UNIX epoch when the signature was created.
  timestamp_seconds?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGoogle {
  // The OAuth token received from Google to access their profile API.
  token?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountSteam {
  // The account token received from Steam to access their profile API.
  token?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** A message sent on a channel. */
export interface ApiChannelMessage {
  // The channel this message belongs to.
  channel_id?: string;
  // The code representing a message type or category.
  code?: number;
  // The content payload.
  content?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was created.
  create_time?: string;
  // The ID of the group, or an empty string if this message was not sent through a group channel.
  group_id?: string;
  // The unique ID of this message.
  message_id?: string;
  // True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  // The name of the chat room, or an empty string if this message was not sent through a chat room.
  room_name?: string;
  // Message sender, usually a user ID.
  sender_id?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the message was last updated.
  update_time?: string;
  // The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
  user_id_one?: string;
  // The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
  user_id_two?: string;
  // The username of the message sender, if any.
  username?: string;
}

/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  // Cacheable cursor to list newer messages. Durable and designed to be stored, unlike next/prev cursors.
  cacheable_cursor?: string;
  // A list of messages.
  messages?: Array<ApiChannelMessage>;
  // The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}

/** Create a group with the current user as owner. */
export interface ApiCreateGroupRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // A description for the group.
  description?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // Maximum number of group members.
  max_count?: number;
  // A unique name for the group.
  name?: string;
  // Mark a group as open or not where only admins can accept members.
  open?: boolean;
}

/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The version hash of the object.
  version?: string;
}

/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}

/** Represents an event to be passed through the server to registered event handlers. */
export interface ApiEvent {
  // True if the event came directly from a client call, false otherwise.
  external?: boolean;
  // An event name, type, category, or identifier.
  name?: string;
  // Arbitrary event property values.
  properties?: Record<string, string>;
  // The time when the event was triggered.
  timestamp?: string;
}

/** A friend of a user. */
export interface ApiFriend {
  // The friend status.  one of "Friend.State".
  state?: number;
  // Time of the latest relationship update.
  update_time?: string;
  // The user object.
  user?: ApiUser;
}

/** A collection of zero or more friends of the user. */
export interface ApiFriendList {
  // Cursor for the next page of results, if any.
  cursor?: string;
  // The Friend objects.
  friends?: Array<ApiFriend>;
}

/**  */
export interface ApiFriendsOfFriendsList {
  // Cursor for the next page of results, if any.
  cursor?: string;
  // User friends of friends.
  friends_of_friends?: Array<FriendsOfFriendsListFriendOfFriend>;
}

/** A group in the server. */
export interface ApiGroup {
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was created.
  create_time?: string;
  // The id of the user who created the group.
  creator_id?: string;
  // A description for the group.
  description?: string;
  // The current count of all members in the group.
  edge_count?: number;
  // The id of a group.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The maximum number of members allowed.
  max_count?: number;
  // Additional information stored as a JSON object.
  metadata?: string;
  // The unique name of the group.
  name?: string;
  // Anyone can join open groups, otherwise only admins can accept members.
  open?: boolean;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the group was last updated.
  update_time?: string;
}

/** One or more groups returned from a listing operation. */
export interface ApiGroupList {
  // A cursor used to get the next page.
  cursor?: string;
  // One or more groups.
  groups?: Array<ApiGroup>;
}

/** A list of users belonging to a group, along with their role. */
export interface ApiGroupUserList {
  // Cursor for the next page of results, if any.
  cursor?: string;
  // User-role pairs for a group.
  group_users?: Array<GroupUserListGroupUser>;
}

/** Represents a complete leaderboard record with all scores and associated metadata. */
export interface ApiLeaderboardRecord {
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record was created.
  create_time?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record expires.
  expiry_time?: string;
  // The ID of the leaderboard this score belongs to.
  leaderboard_id?: string;
  // The maximum number of score updates allowed by the owner.
  max_num_score?: number;
  // Metadata.
  metadata?: string;
  // The number of submissions to this score record.
  num_score?: number;
  // The ID of the score owner, usually a user or group.
  owner_id?: string;
  // The rank of this record.
  rank?: string;
  // The score value.
  score?: string;
  // An optional subscore value.
  subscore?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the leaderboard record was updated.
  update_time?: string;
  // The username of the score owner, if the owner is a user.
  username?: string;
}

/** A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records. */
export interface ApiLeaderboardRecordList {
  // The cursor to send when retrieving the next page, if any.
  next_cursor?: string;
  // A batched set of leaderboard records belonging to specified owners.
  owner_records?: Array<ApiLeaderboardRecord>;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  // The total number of ranks available.
  rank_count?: string;
  // A list of leaderboard records.
  records?: Array<ApiLeaderboardRecord>;
}

/** Link Steam to the current user's account. */
export interface ApiLinkSteamRequest {
  // The Facebook account details.
  account?: ApiAccountSteam;
  // Import Steam friends for the user.
  sync?: boolean;
}

/** List user subscriptions. */
export interface ApiListSubscriptionsRequest {
  //
  cursor?: string;
  //
  limit?: number;
}

/** Represents a realtime match. */
export interface ApiMatch {
  // True if it's an server-managed authoritative match, false otherwise.
  authoritative?: boolean;
  //
  handler_name?: string;
  // Match label, if any.
  label?: string;
  // The ID of the match, can be used to join.
  match_id?: string;
  // Current number of users in the match.
  size?: number;
  //
  tick_rate?: number;
}

/** A list of realtime matches. */
export interface ApiMatchList {
  // A number of matches corresponding to a list operation.
  matches?: Array<ApiMatch>;
}

/** A notification in the server. */
export interface ApiNotification {
  // Category code for this notification.
  code?: number;
  // Content of the notification in JSON.
  content?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the notification was created.
  create_time?: string;
  // ID of the Notification.
  id?: string;
  // True if this notification was persisted to the database.
  persistent?: boolean;
  // ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  // Subject of the notification.
  subject?: string;
}

/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  // Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  // Collection of notifications.
  notifications?: Array<ApiNotification>;
}

/**
* Operator that can be used to override the one set in the leaderboard.
*/
export enum ApiOperator
{
    /*  - NO_OVERRIDE: Do not override the leaderboard operator. */
    NO_OVERRIDE = 0,
    /*  - BEST: Override the leaderboard operator with BEST. */
    BEST = 1,
    /*  - SET: Override the leaderboard operator with SET. */
    SET = 2,
    /*  - INCREMENT: Override the leaderboard operator with INCREMENT. */
    INCREMENT = 3,
    /*  - DECREMENT: Override the leaderboard operator with DECREMENT. */
    DECREMENT = 4,
}

/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The user owner of the object.
  user_id?: string;
}

/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}

/** Execute an Lua function on the server. */
export interface ApiRpc {
  // The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  // The identifier of the function.
  id?: string;
  // The payload of the function which must be a JSON object.
  payload?: string;
}

/** A user's session used to authenticate messages. */
export interface ApiSession {
  // True if the corresponding account was just created, false otherwise.
  created?: boolean;
  // Refresh token that can be used for session token renewal.
  refresh_token?: string;
  // Authentication credentials.
  token?: string;
}

/** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
export interface ApiSessionLogoutRequest {
  // Refresh token to invalidate.
  refresh_token?: string;
  // Session token to log out.
  token?: string;
}

/** Authenticate against the server with a refresh token. */
export interface ApiSessionRefreshRequest {
  // Refresh token.
  token?: string;
  // Extra information that will be bundled in the session token.
  vars?: Record<string, string>;
}

/** An object within the storage engine. */
export interface ApiStorageObject {
  // The collection which stores the object.
  collection?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
  create_time?: string;
  // The key of the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
  update_time?: string;
  // The user owner of the object.
  user_id?: string;
  // The value of the object.
  value?: string;
  // The version hash of the object.
  version?: string;
}

/** A storage acknowledgement. */
export interface ApiStorageObjectAck {
  // The collection which stores the object.
  collection?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was created.
  create_time?: string;
  // The key of the object within the collection.
  key?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the object was last updated.
  update_time?: string;
  // The owner of the object.
  user_id?: string;
  // The version hash of the object.
  version?: string;
}

/** Batch of acknowledgements for the storage object write. */
export interface ApiStorageObjectAcks {
  // Batch of storage write acknowledgements.
  acks?: Array<ApiStorageObjectAck>;
}

/** List of storage objects. */
export interface ApiStorageObjectList {
  // The cursor for the next page of results, if any.
  cursor?: string;
  // The list of storage objects.
  objects?: Array<ApiStorageObject>;
}

/** Batch of storage objects. */
export interface ApiStorageObjects {
  // The batch of storage objects.
  objects?: Array<ApiStorageObject>;
}

/**
* Environment where a purchase/subscription took place,
*/
export enum ApiStoreEnvironment
{
    /* - UNKNOWN: Unknown environment. */
    UNKNOWN = 0,
    /*  - SANDBOX: Sandbox/test environment. */
    SANDBOX = 1,
    /*  - PRODUCTION: Production environment. */
    PRODUCTION = 2,
}

/**
* Validation Provider,
*/
export enum ApiStoreProvider
{
    /* - APPLE_APP_STORE: Apple App Store */
    APPLE_APP_STORE = 0,
    /*  - GOOGLE_PLAY_STORE: Google Play Store */
    GOOGLE_PLAY_STORE = 1,
    /*  - HUAWEI_APP_GALLERY: Huawei App Gallery */
    HUAWEI_APP_GALLERY = 2,
    /*  - FACEBOOK_INSTANT_STORE: Facebook Instant Store */
    FACEBOOK_INSTANT_STORE = 3,
}

/** A list of validated subscriptions stored by Nakama. */
export interface ApiSubscriptionList {
  // The cursor to send when retrieving the next page, if any.
  cursor?: string;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  // Stored validated subscriptions.
  validated_subscriptions?: Array<ApiValidatedSubscription>;
}

/** A tournament on the server. */
export interface ApiTournament {
  // Whether the leaderboard was created authoritatively or not.
  authoritative?: boolean;
  // True if the tournament is active and can enter. A computed value.
  can_enter?: boolean;
  // The category of the tournament. e.g. "vip" could be category 1.
  category?: number;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the tournament was created.
  create_time?: string;
  // The description of the tournament. May be blank.
  description?: string;
  // Duration of the tournament in seconds.
  duration?: number;
  // The UNIX time when the tournament stops being active until next reset. A computed value.
  end_active?: number;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the tournament will be stopped.
  end_time?: string;
  // The ID of the tournament.
  id?: string;
  // The maximum score updates allowed per player for the current tournament.
  max_num_score?: number;
  // The maximum number of players for the tournament.
  max_size?: number;
  // Additional information stored as a JSON object.
  metadata?: string;
  // The UNIX time when the tournament is next playable. A computed value.
  next_reset?: number;
  // Operator.
  operator?: ApiOperator;
  // The UNIX time when the tournament was last reset. A computed value.
  prev_reset?: number;
  // The current number of players in the tournament.
  size?: number;
  // ASC (0) or DESC (1) sort mode of scores in the tournament.
  sort_order?: number;
  // The UNIX time when the tournament start being active. A computed value.
  start_active?: number;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the tournament will start.
  start_time?: string;
  // The title for the tournament.
  title?: string;
}

/** A list of tournaments. */
export interface ApiTournamentList {
  // A pagination cursor (optional).
  cursor?: string;
  // The list of tournaments returned.
  tournaments?: Array<ApiTournament>;
}

/** A set of tournament records which may be part of a tournament records page or a batch of individual records. */
export interface ApiTournamentRecordList {
  // The cursor to send when retireving the next page (optional).
  next_cursor?: string;
  // A batched set of tournament records belonging to specified owners.
  owner_records?: Array<ApiLeaderboardRecord>;
  // The cursor to send when retrieving the previous page (optional).
  prev_cursor?: string;
  // The total number of ranks available.
  rank_count?: string;
  // A list of tournament records.
  records?: Array<ApiLeaderboardRecord>;
}

/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // The display name of the user.
  display_name?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // The timezone set by the user.
  timezone?: string;
  // The username of the user's account.
  username?: string;
}

/** Update fields in a given group. */
export interface ApiUpdateGroupRequest {
  // Avatar URL.
  avatar_url?: string;
  // Description string.
  description?: string;
  // The ID of the group to update.
  group_id?: string;
  // Lang tag.
  lang_tag?: string;
  // Name.
  name?: string;
  // Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
  open?: boolean;
}

/** A user in the server. */
export interface ApiUser {
  // The Apple Sign In ID in the user's account.
  apple_id?: string;
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was created.
  create_time?: string;
  // The display name of the user.
  display_name?: string;
  // Number of related edges to this user.
  edge_count?: number;
  // The Facebook id in the user's account.
  facebook_id?: string;
  // The Facebook Instant Game ID in the user's account.
  facebook_instant_game_id?: string;
  // The Apple Game Center in of the user's account.
  gamecenter_id?: string;
  // The Google id in the user's account.
  google_id?: string;
  // The id of the user's account.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // Additional information stored as a JSON object.
  metadata?: string;
  // Indicates whether the user is currently online.
  online?: boolean;
  // The Steam id in the user's account.
  steam_id?: string;
  // The timezone set by the user.
  timezone?: string;
  // The UNIX time (for gRPC clients) or ISO string (for REST clients) when the user was last updated.
  update_time?: string;
  // The username of the user's account.
  username?: string;
}

/** A list of groups belonging to a user, along with the user's role in each group. */
export interface ApiUserGroupList {
  // Cursor for the next page of results, if any.
  cursor?: string;
  // Group-role pairs for a user.
  user_groups?: Array<UserGroupListUserGroup>;
}

/** A collection of zero or more users. */
export interface ApiUsers {
  // The User objects.
  users?: Array<ApiUser>;
}

/**  */
export interface ApiValidatePurchaseAppleRequest {
  //
  persist?: boolean;
  // Base64 encoded Apple receipt data payload.
  receipt?: string;
}

/**  */
export interface ApiValidatePurchaseFacebookInstantRequest {
  //
  persist?: boolean;
  // Base64 encoded Facebook Instant signedRequest receipt data payload.
  signed_request?: string;
}

/**  */
export interface ApiValidatePurchaseGoogleRequest {
  //
  persist?: boolean;
  // JSON encoded Google purchase payload.
  purchase?: string;
}

/**  */
export interface ApiValidatePurchaseHuaweiRequest {
  //
  persist?: boolean;
  // JSON encoded Huawei InAppPurchaseData.
  purchase?: string;
  // InAppPurchaseData signature.
  signature?: string;
}

/** Validate IAP response. */
export interface ApiValidatePurchaseResponse {
  // Newly seen validated purchases.
  validated_purchases?: Array<ApiValidatedPurchase>;
}

/**  */
export interface ApiValidateSubscriptionAppleRequest {
  // Persist the subscription.
  persist?: boolean;
  // Base64 encoded Apple receipt data payload.
  receipt?: string;
}

/**  */
export interface ApiValidateSubscriptionGoogleRequest {
  // Persist the subscription.
  persist?: boolean;
  // JSON encoded Google purchase payload.
  receipt?: string;
}

/** Validate Subscription response. */
export interface ApiValidateSubscriptionResponse {
  //
  validated_subscription?: ApiValidatedSubscription;
}

/** Validated Purchase stored by Nakama. */
export interface ApiValidatedPurchase {
  // Timestamp when the receipt validation was stored in DB.
  create_time?: string;
  // Whether the purchase was done in production or sandbox environment.
  environment?: ApiStoreEnvironment;
  // Purchase Product ID.
  product_id?: string;
  // Raw provider validation response.
  provider_response?: string;
  // Timestamp when the purchase was done.
  purchase_time?: string;
  //
  refund_time?: string;
  // Whether the purchase had already been validated by Nakama before.
  seen_before?: boolean;
  //
  store?: ApiStoreProvider;
  // Purchase Transaction ID.
  transaction_id?: string;
  // Timestamp when the receipt validation was updated in DB.
  update_time?: string;
  // Purchase User ID.
  user_id?: string;
}

/**  */
export interface ApiValidatedSubscription {
  // Whether the subscription is currently active or not.
  active?: boolean;
  // UNIX Timestamp when the receipt validation was stored in DB.
  create_time?: string;
  // Whether the purchase was done in production or sandbox environment.
  environment?: ApiStoreEnvironment;
  // Subscription expiration time. The subscription can still be auto-renewed to extend the expiration time further.
  expiry_time?: string;
  // Purchase Original transaction ID (we only keep track of the original subscription, not subsequent renewals).
  original_transaction_id?: string;
  // Purchase Product ID.
  product_id?: string;
  // Raw provider notification body.
  provider_notification?: string;
  // Raw provider validation response body.
  provider_response?: string;
  // UNIX Timestamp when the purchase was done.
  purchase_time?: string;
  // Subscription refund time. If this time is set, the subscription was refunded.
  refund_time?: string;
  //
  store?: ApiStoreProvider;
  // UNIX Timestamp when the receipt validation was updated in DB.
  update_time?: string;
  // Subscription User ID.
  user_id?: string;
}

/** The object to store. */
export interface ApiWriteStorageObject {
  // The collection to store the object.
  collection?: string;
  // The key for the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The value of the object.
  value?: string;
  // The version hash of the object to check. Possible values are: ["", "*", "#hash#"].  if-match and if-none-match
  version?: string;
}

/** Write objects to the storage engine. */
export interface ApiWriteStorageObjectsRequest {
  // The objects to store on the server.
  objects?: Array<ApiWriteStorageObject>;
}

export class NakamaApi {

  constructor(readonly serverKey: string, readonly basePath: string, readonly timeoutMs: number) {}

  /** A healthcheck which load balancers can use to check the service. */
  healthcheck(bearerToken: string,
      options: any = {}): Promise<any> {

    const urlPath = "/healthcheck";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete the current user's account. */
  deleteAccount(bearerToken: string,
      options: any = {}): Promise<any> {

    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch the current user's account. */
  getAccount(bearerToken: string,
      options: any = {}): Promise<ApiAccount> {

    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in the current user's account. */
  updateAccount(bearerToken: string,
      body:ApiUpdateAccountRequest,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with an Apple ID against the server. */
  authenticateApple(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountApple,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/apple";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a custom id against the server. */
  authenticateCustom(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountCustom,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/custom";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a device id against the server. */
  authenticateDevice(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountDevice,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/device";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with an email+password against the server. */
  authenticateEmail(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountEmail,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/email";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a Facebook OAuth token against the server. */
  authenticateFacebook(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountFacebook,
      create?:boolean,
      username?:string,
      sync?:boolean,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with a Facebook Instant Game token against the server. */
  authenticateFacebookInstantGame(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountFacebookInstantGame,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/facebookinstantgame";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Apple's GameCenter against the server. */
  authenticateGameCenter(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountGameCenter,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/gamecenter";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Google against the server. */
  authenticateGoogle(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountGoogle,
      create?:boolean,
      username?:string,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/google";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Authenticate a user with Steam against the server. */
  authenticateSteam(basicAuthUsername: string,
    basicAuthPassword: string,
      account:ApiAccountSteam,
      create?:boolean,
      username?:string,
      sync?:boolean,
      options: any = {}): Promise<ApiSession> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/authenticate/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("create", create);
    queryParams.set("username", username);
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add an Apple ID to the social profiles on the current user's account. */
  linkApple(bearerToken: string,
      body:ApiAccountApple,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add a custom ID to the social profiles on the current user's account. */
  linkCustom(bearerToken: string,
      body:ApiAccountCustom,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/custom";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add a device ID to the social profiles on the current user's account. */
  linkDevice(bearerToken: string,
      body:ApiAccountDevice,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/device";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add an email+password to the social profiles on the current user's account. */
  linkEmail(bearerToken: string,
      body:ApiAccountEmail,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/email";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Facebook to the social profiles on the current user's account. */
  linkFacebook(bearerToken: string,
      account:ApiAccountFacebook,
      sync?:boolean,
      options: any = {}): Promise<any> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("sync", sync);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Facebook Instant Game to the social profiles on the current user's account. */
  linkFacebookInstantGame(bearerToken: string,
      body:ApiAccountFacebookInstantGame,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Apple's GameCenter to the social profiles on the current user's account. */
  linkGameCenter(bearerToken: string,
      body:ApiAccountGameCenter,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Google to the social profiles on the current user's account. */
  linkGoogle(bearerToken: string,
      body:ApiAccountGoogle,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add Steam to the social profiles on the current user's account. */
  linkSteam(bearerToken: string,
      body:ApiLinkSteamRequest,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/link/steam";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Refresh a user's session using a refresh token retrieved from a previous authentication request. */
  sessionRefresh(basicAuthUsername: string,
    basicAuthPassword: string,
      body:ApiSessionRefreshRequest,
      options: any = {}): Promise<ApiSession> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/session/refresh";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
		if (basicAuthUsername) {
			fetchOptions.headers["Authorization"] = "Basic " + encode(basicAuthUsername + ":" + basicAuthPassword);
		}

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the Apple ID from the social profiles on the current user's account. */
  unlinkApple(bearerToken: string,
      body:ApiAccountApple,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the custom ID from the social profiles on the current user's account. */
  unlinkCustom(bearerToken: string,
      body:ApiAccountCustom,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/custom";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the device ID from the social profiles on the current user's account. */
  unlinkDevice(bearerToken: string,
      body:ApiAccountDevice,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/device";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove the email+password from the social profiles on the current user's account. */
  unlinkEmail(bearerToken: string,
      body:ApiAccountEmail,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/email";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Facebook from the social profiles on the current user's account. */
  unlinkFacebook(bearerToken: string,
      body:ApiAccountFacebook,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/facebook";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Facebook Instant Game profile from the social profiles on the current user's account. */
  unlinkFacebookInstantGame(bearerToken: string,
      body:ApiAccountFacebookInstantGame,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/facebookinstantgame";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Apple's GameCenter from the social profiles on the current user's account. */
  unlinkGameCenter(bearerToken: string,
      body:ApiAccountGameCenter,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/gamecenter";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Google from the social profiles on the current user's account. */
  unlinkGoogle(bearerToken: string,
      body:ApiAccountGoogle,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Remove Steam from the social profiles on the current user's account. */
  unlinkSteam(bearerToken: string,
      body:ApiAccountSteam,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/account/unlink/steam";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List a channel's message history. */
  listChannelMessages(bearerToken: string,
      channelId:string,
      limit?:number,
      forward?:boolean,
      cursor?:string,
      options: any = {}): Promise<ApiChannelMessageList> {

    if (channelId === null || channelId === undefined) {
      throw new Error("'channelId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/channel/{channelId}"
        .replace("{channelId}", encodeURIComponent(String(channelId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("forward", forward);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Submit an event for processing in the server's registered runtime custom events handler. */
  event(bearerToken: string,
      body:ApiEvent,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/event";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more users by ID or username. */
  deleteFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {

    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all friends for the current user. */
  listFriends(bearerToken: string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiFriendList> {

    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add friends by ID or username to a user's account. */
  addFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {

    const urlPath = "/v2/friend";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Block one or more users by ID or username. */
  blockFriends(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      options: any = {}): Promise<any> {

    const urlPath = "/v2/friend/block";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Import Facebook friends and add them to a user's account. */
  importFacebookFriends(bearerToken: string,
      account:ApiAccountFacebook,
      reset?:boolean,
      options: any = {}): Promise<any> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/friend/facebook";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List friends of friends for the current user. */
  listFriendsOfFriends(bearerToken: string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiFriendsOfFriendsList> {

    const urlPath = "/v2/friend/friends";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Import Steam friends and add them to a user's account. */
  importSteamFriends(bearerToken: string,
      account:ApiAccountSteam,
      reset?:boolean,
      options: any = {}): Promise<any> {

    if (account === null || account === undefined) {
      throw new Error("'account' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/friend/steam";
    const queryParams = new Map<string, any>();
    queryParams.set("reset", reset);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(account || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List groups based on given filters. */
  listGroups(bearerToken: string,
      name?:string,
      cursor?:string,
      limit?:number,
      langTag?:string,
      members?:number,
      open?:boolean,
      options: any = {}): Promise<ApiGroupList> {

    const urlPath = "/v2/group";
    const queryParams = new Map<string, any>();
    queryParams.set("name", name);
    queryParams.set("cursor", cursor);
    queryParams.set("limit", limit);
    queryParams.set("lang_tag", langTag);
    queryParams.set("members", members);
    queryParams.set("open", open);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Create a new group with the current user as the owner. */
  createGroup(bearerToken: string,
      body:ApiCreateGroupRequest,
      options: any = {}): Promise<ApiGroup> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a group by ID. */
  deleteGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Update fields in a given group. */
  updateGroup(bearerToken: string,
      groupId:string,
      body:ApiUpdateGroupRequest,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Add users to a group. */
  addGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/add"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Ban a set of users from a group. */
  banGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/ban"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Demote a set of users in a group to the next role down. */
  demoteGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/demote"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Immediately join an open group, or request to join a closed one. */
  joinGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/join"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Kick a set of users from a group. */
  kickGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/kick"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Leave a group the user is a member of. */
  leaveGroup(bearerToken: string,
      groupId:string,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/leave"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Promote a set of users in a group to the next role up. */
  promoteGroupUsers(bearerToken: string,
      groupId:string,
      userIds?:Array<string>,
      options: any = {}): Promise<any> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/promote"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_ids", userIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List all users that are part of a group. */
  listGroupUsers(bearerToken: string,
      groupId:string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiGroupUserList> {

    if (groupId === null || groupId === undefined) {
      throw new Error("'groupId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/group/{groupId}/user"
        .replace("{groupId}", encodeURIComponent(String(groupId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate Apple IAP Receipt */
  validatePurchaseApple(bearerToken: string,
      body:ApiValidatePurchaseAppleRequest,
      options: any = {}): Promise<ApiValidatePurchaseResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/purchase/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate FB Instant IAP Receipt */
  validatePurchaseFacebookInstant(bearerToken: string,
      body:ApiValidatePurchaseFacebookInstantRequest,
      options: any = {}): Promise<ApiValidatePurchaseResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/purchase/facebookinstant";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate Google IAP Receipt */
  validatePurchaseGoogle(bearerToken: string,
      body:ApiValidatePurchaseGoogleRequest,
      options: any = {}): Promise<ApiValidatePurchaseResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/purchase/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate Huawei IAP Receipt */
  validatePurchaseHuawei(bearerToken: string,
      body:ApiValidatePurchaseHuaweiRequest,
      options: any = {}): Promise<ApiValidatePurchaseResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/purchase/huawei";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List user's subscriptions. */
  listSubscriptions(bearerToken: string,
      body:ApiListSubscriptionsRequest,
      options: any = {}): Promise<ApiSubscriptionList> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/subscription";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate Apple Subscription Receipt */
  validateSubscriptionApple(bearerToken: string,
      body:ApiValidateSubscriptionAppleRequest,
      options: any = {}): Promise<ApiValidateSubscriptionResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/subscription/apple";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Validate Google Subscription Receipt */
  validateSubscriptionGoogle(bearerToken: string,
      body:ApiValidateSubscriptionGoogleRequest,
      options: any = {}): Promise<ApiValidateSubscriptionResponse> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/subscription/google";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Get subscription by product id. */
  getSubscription(bearerToken: string,
      productId:string,
      options: any = {}): Promise<ApiValidatedSubscription> {

    if (productId === null || productId === undefined) {
      throw new Error("'productId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/iap/subscription/{productId}"
        .replace("{productId}", encodeURIComponent(String(productId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a leaderboard record. */
  deleteLeaderboardRecord(bearerToken: string,
      leaderboardId:string,
      options: any = {}): Promise<any> {

    if (leaderboardId === null || leaderboardId === undefined) {
      throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/leaderboard/{leaderboardId}"
        .replace("{leaderboardId}", encodeURIComponent(String(leaderboardId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List leaderboard records. */
  listLeaderboardRecords(bearerToken: string,
      leaderboardId:string,
      ownerIds?:Array<string>,
      limit?:number,
      cursor?:string,
      expiry?:string,
      options: any = {}): Promise<ApiLeaderboardRecordList> {

    if (leaderboardId === null || leaderboardId === undefined) {
      throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/leaderboard/{leaderboardId}"
        .replace("{leaderboardId}", encodeURIComponent(String(leaderboardId)));
    const queryParams = new Map<string, any>();
    queryParams.set("owner_ids", ownerIds);
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);
    queryParams.set("expiry", expiry);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Write a record to a leaderboard. */
  writeLeaderboardRecord(bearerToken: string,
      leaderboardId:string,
      record:WriteLeaderboardRecordRequestLeaderboardRecordWrite,
      options: any = {}): Promise<ApiLeaderboardRecord> {

    if (leaderboardId === null || leaderboardId === undefined) {
      throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
    }
    if (record === null || record === undefined) {
      throw new Error("'record' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/leaderboard/{leaderboardId}"
        .replace("{leaderboardId}", encodeURIComponent(String(leaderboardId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(record || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List leaderboard records that belong to a user. */
  listLeaderboardRecordsAroundOwner(bearerToken: string,
      leaderboardId:string,
      ownerId:string,
      limit?:number,
      expiry?:string,
      cursor?:string,
      options: any = {}): Promise<ApiLeaderboardRecordList> {

    if (leaderboardId === null || leaderboardId === undefined) {
      throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
    }
    if (ownerId === null || ownerId === undefined) {
      throw new Error("'ownerId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/leaderboard/{leaderboardId}/owner/{ownerId}"
        .replace("{leaderboardId}", encodeURIComponent(String(leaderboardId)))
        .replace("{ownerId}", encodeURIComponent(String(ownerId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("expiry", expiry);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch list of running matches. */
  listMatches(bearerToken: string,
      limit?:number,
      authoritative?:boolean,
      label?:string,
      minSize?:number,
      maxSize?:number,
      query?:string,
      options: any = {}): Promise<ApiMatchList> {

    const urlPath = "/v2/match";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("authoritative", authoritative);
    queryParams.set("label", label);
    queryParams.set("min_size", minSize);
    queryParams.set("max_size", maxSize);
    queryParams.set("query", query);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more notifications for the current user. */
  deleteNotifications(bearerToken: string,
      ids?:Array<string>,
      options: any = {}): Promise<any> {

    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch list of notifications. */
  listNotifications(bearerToken: string,
      limit?:number,
      cacheableCursor?:string,
      options: any = {}): Promise<ApiNotificationList> {

    const urlPath = "/v2/notification";
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cacheable_cursor", cacheableCursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Execute a Lua function on the server. */
  rpcFunc2(bearerToken: string,
    id:string,
    payload?:string,
    httpKey?:string,
    options: any = {}): Promise<ApiRpc> {

  if (id === null || id === undefined) {
    throw new Error("'id' is a required parameter but is null or undefined.");
  }
  const urlPath = "/v2/rpc/{id}"
      .replace("{id}", encodeURIComponent(String(id)));
  const queryParams = new Map<string, any>();
  queryParams.set("payload", payload);
  queryParams.set("http_key", httpKey);

  let bodyJson : string = "";

  const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
  const fetchOptions = buildFetchOptions("GET", options, bodyJson);
  if (bearerToken) {
      fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
  }

  return Promise.race([
    fetch(fullUrl, fetchOptions).then((response) => {
      if (response.status == 204) {
        return response;
      } else if (response.status >= 200 && response.status < 300) {
        return response.json();
      } else {
        throw response;
      }
    }),
    new Promise((_, reject) =>
      setTimeout(reject, this.timeoutMs, "Request timed out.")
    ),
  ]);
}

  /** Execute a Lua function on the server. */
  rpcFunc(bearerToken: string,
      id:string,
      body:string,
      httpKey?:string,
      options: any = {}): Promise<ApiRpc> {

    if (id === null || id === undefined) {
      throw new Error("'id' is a required parameter but is null or undefined.");
    }
    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/rpc/{id}"
        .replace("{id}", encodeURIComponent(String(id)));
    const queryParams = new Map<string, any>();
    queryParams.set("http_key", httpKey);

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
  }

  /** Log out a session, invalidate a refresh token, or log out all sessions/refresh tokens for a user. */
  sessionLogout(bearerToken: string,
      body:ApiSessionLogoutRequest,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/session/logout";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Get storage objects. */
  readStorageObjects(bearerToken: string,
      body:ApiReadStorageObjectsRequest,
      options: any = {}): Promise<ApiStorageObjects> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Write objects into the storage engine. */
  writeStorageObjects(bearerToken: string,
      body:ApiWriteStorageObjectsRequest,
      options: any = {}): Promise<ApiStorageObjectAcks> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete one or more objects by ID or username. */
  deleteStorageObjects(bearerToken: string,
      body:ApiDeleteStorageObjectsRequest,
      options: any = {}): Promise<any> {

    if (body === null || body === undefined) {
      throw new Error("'body' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/delete";
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(body || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List publicly readable storage objects in a given collection. */
  listStorageObjects(bearerToken: string,
      collection:string,
      userId?:string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiStorageObjectList> {

    if (collection === null || collection === undefined) {
      throw new Error("'collection' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/{collection}"
        .replace("{collection}", encodeURIComponent(String(collection)));
    const queryParams = new Map<string, any>();
    queryParams.set("user_id", userId);
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List publicly readable storage objects in a given collection. */
  listStorageObjects2(bearerToken: string,
      collection:string,
      userId:string,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiStorageObjectList> {

    if (collection === null || collection === undefined) {
      throw new Error("'collection' is a required parameter but is null or undefined.");
    }
    if (userId === null || userId === undefined) {
      throw new Error("'userId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/storage/{collection}/{userId}"
        .replace("{collection}", encodeURIComponent(String(collection)))
        .replace("{userId}", encodeURIComponent(String(userId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List current or upcoming tournaments. */
  listTournaments(bearerToken: string,
      categoryStart?:number,
      categoryEnd?:number,
      startTime?:number,
      endTime?:number,
      limit?:number,
      cursor?:string,
      options: any = {}): Promise<ApiTournamentList> {

    const urlPath = "/v2/tournament";
    const queryParams = new Map<string, any>();
    queryParams.set("category_start", categoryStart);
    queryParams.set("category_end", categoryEnd);
    queryParams.set("start_time", startTime);
    queryParams.set("end_time", endTime);
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Delete a tournament record. */
  deleteTournamentRecord(bearerToken: string,
      tournamentId:string,
      options: any = {}): Promise<any> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("DELETE", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List tournament records. */
  listTournamentRecords(bearerToken: string,
      tournamentId:string,
      ownerIds?:Array<string>,
      limit?:number,
      cursor?:string,
      expiry?:string,
      options: any = {}): Promise<ApiTournamentRecordList> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)));
    const queryParams = new Map<string, any>();
    queryParams.set("owner_ids", ownerIds);
    queryParams.set("limit", limit);
    queryParams.set("cursor", cursor);
    queryParams.set("expiry", expiry);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Write a record to a tournament. */
  writeTournamentRecord2(bearerToken: string,
      tournamentId:string,
      record:WriteTournamentRecordRequestTournamentRecordWrite,
      options: any = {}): Promise<ApiLeaderboardRecord> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    if (record === null || record === undefined) {
      throw new Error("'record' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(record || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Write a record to a tournament. */
  writeTournamentRecord(bearerToken: string,
      tournamentId:string,
      record:WriteTournamentRecordRequestTournamentRecordWrite,
      options: any = {}): Promise<ApiLeaderboardRecord> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    if (record === null || record === undefined) {
      throw new Error("'record' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";
    bodyJson = JSON.stringify(record || {});

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("PUT", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Attempt to join an open and running tournament. */
  joinTournament(bearerToken: string,
      tournamentId:string,
      options: any = {}): Promise<any> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}/join"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)));
    const queryParams = new Map<string, any>();

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("POST", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List tournament records for a given owner. */
  listTournamentRecordsAroundOwner(bearerToken: string,
      tournamentId:string,
      ownerId:string,
      limit?:number,
      expiry?:string,
      cursor?:string,
      options: any = {}): Promise<ApiTournamentRecordList> {

    if (tournamentId === null || tournamentId === undefined) {
      throw new Error("'tournamentId' is a required parameter but is null or undefined.");
    }
    if (ownerId === null || ownerId === undefined) {
      throw new Error("'ownerId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/tournament/{tournamentId}/owner/{ownerId}"
        .replace("{tournamentId}", encodeURIComponent(String(tournamentId)))
        .replace("{ownerId}", encodeURIComponent(String(ownerId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("expiry", expiry);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** Fetch zero or more users by ID and/or username. */
  getUsers(bearerToken: string,
      ids?:Array<string>,
      usernames?:Array<string>,
      facebookIds?:Array<string>,
      options: any = {}): Promise<ApiUsers> {

    const urlPath = "/v2/user";
    const queryParams = new Map<string, any>();
    queryParams.set("ids", ids);
    queryParams.set("usernames", usernames);
    queryParams.set("facebook_ids", facebookIds);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

  /** List groups the current user belongs to. */
  listUserGroups(bearerToken: string,
      userId:string,
      limit?:number,
      state?:number,
      cursor?:string,
      options: any = {}): Promise<ApiUserGroupList> {

    if (userId === null || userId === undefined) {
      throw new Error("'userId' is a required parameter but is null or undefined.");
    }
    const urlPath = "/v2/user/{userId}/group"
        .replace("{userId}", encodeURIComponent(String(userId)));
    const queryParams = new Map<string, any>();
    queryParams.set("limit", limit);
    queryParams.set("state", state);
    queryParams.set("cursor", cursor);

    let bodyJson : string = "";

    const fullUrl = this.buildFullUrl(this.basePath, urlPath, queryParams);
    const fetchOptions = buildFetchOptions("GET", options, bodyJson);
    if (bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + bearerToken;
    }

    return Promise.race([
      fetch(fullUrl, fetchOptions).then((response) => {
        if (response.status == 204) {
          return response;
        } else if (response.status >= 200 && response.status < 300) {
          return response.json();
        } else {
          throw response;
        }
      }),
      new Promise((_, reject) =>
        setTimeout(reject, this.timeoutMs, "Request timed out.")
      ),
    ]);
}

    buildFullUrl(basePath: string, fragment: string, queryParams: Map<string, any>) {
        let fullPath = basePath + fragment + "?";

        for (let [k, v] of queryParams) {
            if (v instanceof Array) {
                fullPath += v.reduce((prev: any, curr: any) => {
                return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
                }, "");
            } else {
                if (v != null) {
                    fullPath += encodeURIComponent(k) + "=" + encodeURIComponent(v) + "&";
                }
            }
        }

        return fullPath;
    }
};
