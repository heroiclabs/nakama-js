/* eslint-disable */
// *
//  The Nakama server RPC protocol for games and apps.
//
import { Timestamp } from '../../../../google/protobuf/timestamp';
import * as Long from 'long';
import { Writer, Reader } from 'protobufjs/minimal';
import { BoolValue, Int32Value, StringValue, UInt32Value, Int64Value } from '../../../../google/protobuf/wrappers';


/**
 *  A user with additional account details. Always the current user.
 */
export interface Account {
  /**
   *  The user object.
   */
  user?: User;
  /**
   *  The user's wallet data.
   */
  wallet: string;
  /**
   *  The email address of the user.
   */
  email: string;
  /**
   *  The devices which belong to the user's account.
   */
  devices: AccountDevice[];
  /**
   *  The custom id in the user's account.
   */
  custom_id: string;
  /**
   *  The UNIX time when the user's email was verified.
   */
  verify_time?: Date;
  /**
   *  The UNIX time when the user's account was disabled/banned.
   */
  disable_time?: Date;
}

/**
 *  Send a custom ID to the server. Used with authenticate/link/unlink.
 */
export interface AccountCustom {
  /**
   *  A custom identifier.
   */
  id: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountCustom_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send a device to the server. Used with authenticate/link/unlink and user.
 */
export interface AccountDevice {
  /**
   *  A device identifier. Should be obtained by a platform-specific device API.
   */
  id: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountDevice_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send an email with password to the server. Used with authenticate/link/unlink.
 */
export interface AccountEmail {
  /**
   *  A valid RFC-5322 email address.
   */
  email: string;
  /**
   *  A password for the user account.
   */
  password: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountEmail_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send a Facebook token to the server. Used with authenticate/link/unlink.
 */
export interface AccountFacebook {
  /**
   *  The OAuth token received from Facebook to access their profile API.
   */
  token: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountFacebook_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send a Facebook Instant Game token to the server. Used with authenticate/link/unlink.
 */
export interface AccountFacebookInstantGame {
  /**
   *  The OAuth token received from a Facebook Instant Game that may be decoded with the Application Secret (must be available with the nakama configuration)
   */
  signed_player_info: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountFacebookInstantGame_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink.
 */
export interface AccountGameCenter {
  /**
   *  Player ID (generated by GameCenter).
   */
  player_id: string;
  /**
   *  Bundle ID (generated by GameCenter).
   */
  bundle_id: string;
  /**
   *  Time since UNIX epoch when the signature was created.
   */
  timestamp_seconds: number;
  /**
   *  A random "NSString" used to compute the hash and keep it randomized.
   */
  salt: string;
  /**
   *  The verification signature data generated.
   */
  signature: string;
  /**
   *  The URL for the public encryption key.
   */
  public_key_url: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountGameCenter_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send a Google token to the server. Used with authenticate/link/unlink.
 */
export interface AccountGoogle {
  /**
   *  The OAuth token received from Google to access their profile API.
   */
  token: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountGoogle_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Send a Steam token to the server. Used with authenticate/link/unlink.
 */
export interface AccountSteam {
  /**
   *  The account token received from Steam to access their profile API.
   */
  token: string;
  /**
   *  Extra information that will be bundled in the session token.
   */
  vars: { [key: string]: string };
}

export interface AccountSteam_VarsEntry {
  key: string;
  value: string;
}

/**
 *  Add one or more friends to the current user.
 */
export interface AddFriendsRequest {
  /**
   *  The account id of a user.
   */
  ids: string[];
  /**
   *  The account username of a user.
   */
  usernames: string[];
}

/**
 *  Add users to a group.
 */
export interface AddGroupUsersRequest {
  /**
   *  The group to add users to.
   */
  group_id: string;
  /**
   *  The users to add.
   */
  user_ids: string[];
}

/**
 *  Authenticate against the server with a custom ID.
 */
export interface AuthenticateCustomRequest {
  /**
   *  The custom account details.
   */
  account?: AccountCustom;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with a device ID.
 */
export interface AuthenticateDeviceRequest {
  /**
   *  The device account details.
   */
  account?: AccountDevice;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with email+password.
 */
export interface AuthenticateEmailRequest {
  /**
   *  The email account details.
   */
  account?: AccountEmail;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with Facebook.
 */
export interface AuthenticateFacebookRequest {
  /**
   *  The Facebook account details.
   */
  account?: AccountFacebook;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
  /**
   *  Import Facebook friends for the user.
   */
  sync?: boolean;
}

/**
 *  Authenticate against the server with Facebook Instant Game token.
 */
export interface AuthenticateFacebookInstantGameRequest {
  /**
   *  The Facebook Instant Game account details.
   */
  account?: AccountFacebookInstantGame;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with Apple's Game Center.
 */
export interface AuthenticateGameCenterRequest {
  /**
   *  The Game Center account details.
   */
  account?: AccountGameCenter;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with Google.
 */
export interface AuthenticateGoogleRequest {
  /**
   *  The Google account details.
   */
  account?: AccountGoogle;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Authenticate against the server with Steam.
 */
export interface AuthenticateSteamRequest {
  /**
   *  The Steam account details.
   */
  account?: AccountSteam;
  /**
   *  Register the account if the user does not already exist.
   */
  create?: boolean;
  /**
   *  Set the username on the account at register. Must be unique.
   */
  username: string;
}

/**
 *  Ban users from a group.
 */
export interface BanGroupUsersRequest {
  /**
   *  The group to ban users from.
   */
  group_id: string;
  /**
   *  The users to ban.
   */
  user_ids: string[];
}

/**
 *  Block one or more friends for the current user.
 */
export interface BlockFriendsRequest {
  /**
   *  The account id of a user.
   */
  ids: string[];
  /**
   *  The account username of a user.
   */
  usernames: string[];
}

/**
 *  A message sent on a channel.
 */
export interface ChannelMessage {
  /**
   *  The channel this message belongs to.
   */
  channel_id: string;
  /**
   *  The unique ID of this message.
   */
  message_id: string;
  /**
   *  The code representing a message type or category.
   */
  code?: number;
  /**
   *  Message sender, usually a user ID.
   */
  sender_id: string;
  /**
   *  The username of the message sender, if any.
   */
  username: string;
  /**
   *  The content payload.
   */
  content: string;
  /**
   *  The UNIX time when the message was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the message was last updated.
   */
  update_time?: Date;
  /**
   *  True if the message was persisted to the channel's history, false otherwise.
   */
  persistent?: boolean;
  /**
   *  The name of the chat room, or an empty string if this message was not sent through a chat room.
   */
  room_name: string;
  /**
   *  The ID of the group, or an empty string if this message was not sent through a group channel.
   */
  group_id: string;
  /**
   *  The ID of the first DM user, or an empty string if this message was not sent through a DM chat.
   */
  user_id_one: string;
  /**
   *  The ID of the second DM user, or an empty string if this message was not sent through a DM chat.
   */
  user_id_two: string;
}

/**
 *  A list of channel messages, usually a result of a list operation.
 */
export interface ChannelMessageList {
  /**
   *  A list of messages.
   */
  messages: ChannelMessage[];
  /**
   *  The cursor to send when retireving the next page, if any.
   */
  next_cursor: string;
  /**
   *  The cursor to send when retrieving the previous page, if any.
   */
  prev_cursor: string;
}

/**
 *  Create a group with the current user as owner.
 */
export interface CreateGroupRequest {
  /**
   *  A unique name for the group.
   */
  name: string;
  /**
   *  A description for the group.
   */
  description: string;
  /**
   *  The language expected to be a tag which follows the BCP-47 spec.
   */
  lang_tag: string;
  /**
   *  A URL for an avatar image.
   */
  avatar_url: string;
  /**
   *  Mark a group as open or not where only admins can accept members.
   */
  open: boolean;
  /**
   *  Maximum number of group members.
   */
  max_count: number;
}

/**
 *  Delete one or more friends for the current user.
 */
export interface DeleteFriendsRequest {
  /**
   *  The account id of a user.
   */
  ids: string[];
  /**
   *  The account username of a user.
   */
  usernames: string[];
}

/**
 *  Delete a group the user has access to.
 */
export interface DeleteGroupRequest {
  /**
   *  The id of a group.
   */
  group_id: string;
}

/**
 *  Delete a leaderboard record.
 */
export interface DeleteLeaderboardRecordRequest {
  /**
   *  The leaderboard ID to delete from.
   */
  leaderboard_id: string;
}

/**
 *  Delete one or more notifications for the current user.
 */
export interface DeleteNotificationsRequest {
  /**
   *  The id of notifications.
   */
  ids: string[];
}

/**
 *  Storage objects to delete.
 */
export interface DeleteStorageObjectId {
  /**
   *  The collection which stores the object.
   */
  collection: string;
  /**
   *  The key of the object within the collection.
   */
  key: string;
  /**
   *  The version hash of the object.
   */
  version: string;
}

/**
 *  Batch delete storage objects.
 */
export interface DeleteStorageObjectsRequest {
  /**
   *  Batch of storage objects.
   */
  object_ids: DeleteStorageObjectId[];
}

/**
 *  Represents an event to be passed through the server to registered event handlers.
 */
export interface Event {
  /**
   *  An event name, type, category, or identifier.
   */
  name: string;
  /**
   *  Arbitrary event property values.
   */
  properties: { [key: string]: string };
  /**
   *  The time when the event was triggered.
   */
  timestamp?: Date;
  /**
   *  True if the event came directly from a client call, false otherwise.
   */
  external: boolean;
}

export interface Event_PropertiesEntry {
  key: string;
  value: string;
}

/**
 *  A friend of a user.
 */
export interface Friend {
  /**
   *  The user object.
   */
  user?: User;
  /**
   *  The friend status.
   */
  state?: number;
  /**
   *  Time of the latest relationship update.
   */
  update_time?: Date;
}

/**
 *  A collection of zero or more friends of the user.
 */
export interface FriendList {
  /**
   *  The Friend objects.
   */
  friends: Friend[];
  /**
   *  Cursor for the next page of results, if any.
   */
  cursor: string;
}

/**
 *  Fetch a batch of zero or more users from the server.
 */
export interface GetUsersRequest {
  /**
   *  The account id of a user.
   */
  ids: string[];
  /**
   *  The account username of a user.
   */
  usernames: string[];
  /**
   *  The Facebook ID of a user.
   */
  facebook_ids: string[];
}

/**
 *  A group in the server.
 */
export interface Group {
  /**
   *  The id of a group.
   */
  id: string;
  /**
   *  The id of the user who created the group.
   */
  creator_id: string;
  /**
   *  The unique name of the group.
   */
  name: string;
  /**
   *  A description for the group.
   */
  description: string;
  /**
   *  The language expected to be a tag which follows the BCP-47 spec.
   */
  lang_tag: string;
  /**
   *  Additional information stored as a JSON object.
   */
  metadata: string;
  /**
   *  A URL for an avatar image.
   */
  avatar_url: string;
  /**
   *  Anyone can join open groups, otherwise only admins can accept members.
   */
  open?: boolean;
  /**
   *  The current count of all members in the group.
   */
  edge_count: number;
  /**
   *  The maximum number of members allowed.
   */
  max_count: number;
  /**
   *  The UNIX time when the group was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the group was last updated.
   */
  update_time?: Date;
}

/**
 *  One or more groups returned from a listing operation.
 */
export interface GroupList {
  /**
   *  One or more groups.
   */
  groups: Group[];
  /**
   *  A cursor used to get the next page.
   */
  cursor: string;
}

/**
 *  A list of users belonging to a group, along with their role.
 */
export interface GroupUserList {
  /**
   *  User-role pairs for a group.
   */
  group_users: GroupUserList_GroupUser[];
  /**
   *  Cursor for the next page of results, if any.
   */
  cursor: string;
}

/**
 *  A single user-role pair.
 */
export interface GroupUserList_GroupUser {
  /**
   *  User.
   */
  user?: User;
  /**
   *  Their relationship to the group.
   */
  state?: number;
}

/**
 *  Import Facebook friends into the current user's account.
 */
export interface ImportFacebookFriendsRequest {
  /**
   *  The Facebook account details.
   */
  account?: AccountFacebook;
  /**
   *  Reset the current user's friends list.
   */
  reset?: boolean;
}

/**
 *  Immediately join an open group, or request to join a closed one.
 */
export interface JoinGroupRequest {
  /**
   *  The group ID to join. The group must already exist.
   */
  group_id: string;
}

/**
 *  The request to join a tournament.
 */
export interface JoinTournamentRequest {
  /**
   *  The ID of the tournament to join. The tournament must already exist.
   */
  tournament_id: string;
}

/**
 *  Kick a set of users from a group.
 */
export interface KickGroupUsersRequest {
  /**
   *  The group ID to kick from.
   */
  group_id: string;
  /**
   *  The users to kick.
   */
  user_ids: string[];
}

/**
 *  Represents a complete leaderboard record with all scores and associated metadata.
 */
export interface LeaderboardRecord {
  /**
   *  The ID of the leaderboard this score belongs to.
   */
  leaderboard_id: string;
  /**
   *  The ID of the score owner, usually a user or group.
   */
  owner_id: string;
  /**
   *  The username of the score owner, if the owner is a user.
   */
  username?: string;
  /**
   *  The score value.
   */
  score: number;
  /**
   *  An optional subscore value.
   */
  subscore: number;
  /**
   *  The number of submissions to this score record.
   */
  num_score: number;
  /**
   *  Metadata.
   */
  metadata: string;
  /**
   *  The UNIX time when the leaderboard record was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the leaderboard record was updated.
   */
  update_time?: Date;
  /**
   *  The UNIX time when the leaderboard record expires.
   */
  expiry_time?: Date;
  /**
   *  The rank of this record.
   */
  rank: number;
  /**
   *  The maximum number of score updates allowed by the owner.
   */
  max_num_score: number;
}

/**
 *  A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records.
 */
export interface LeaderboardRecordList {
  /**
   *  A list of leaderboard records.
   */
  records: LeaderboardRecord[];
  /**
   *  A batched set of leaderboard records belonging to specified owners.
   */
  owner_records: LeaderboardRecord[];
  /**
   *  The cursor to send when retrieving the next page, if any.
   */
  next_cursor: string;
  /**
   *  The cursor to send when retrieving the previous page, if any.
   */
  prev_cursor: string;
}

/**
 *  Leave a group.
 */
export interface LeaveGroupRequest {
  /**
   *  The group ID to leave.
   */
  group_id: string;
}

/**
 *  Link Facebook to the current user's account.
 */
export interface LinkFacebookRequest {
  /**
   *  The Facebook account details.
   */
  account?: AccountFacebook;
  /**
   *  Import Facebook friends for the user.
   */
  sync?: boolean;
}

/**
 *  List a channel's message history.
 */
export interface ListChannelMessagesRequest {
  /**
   *  The channel ID to list from.
   */
  channel_id: string;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  True if listing should be older messages to newer, false if reverse.
   */
  forward?: boolean;
  /**
   *  A pagination cursor, if any.
   */
  cursor: string;
}

/**
 *  List friends for a user.
 */
export interface ListFriendsRequest {
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The friend state to list.
   */
  state?: number;
  /**
   *  An optional next page cursor.
   */
  cursor: string;
}

/**
 *  List groups based on given filters.
 */
export interface ListGroupsRequest {
  /**
   *  List groups that contain this value in their names.
   */
  name: string;
  /**
   *  Optional pagination cursor.
   */
  cursor: string;
  /**
   *  Max number of groups to return. Between 1 and 100.
   */
  limit?: number;
}

/**
 *  List all users that are part of a group.
 */
export interface ListGroupUsersRequest {
  /**
   *  The group ID to list from.
   */
  group_id: string;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The group user state to list.
   */
  state?: number;
  /**
   *  An optional next page cursor.
   */
  cursor: string;
}

/**
 *  List leaerboard records from a given leaderboard around the owner.
 */
export interface ListLeaderboardRecordsAroundOwnerRequest {
  /**
   *  The ID of the tournament to list for.
   */
  leaderboard_id: string;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The owner to retrieve records around.
   */
  owner_id: string;
  /**
   *  Expiry in seconds (since epoch) to begin fetching records from.
   */
  expiry?: number;
}

/**
 *  List leaderboard records from a given leaderboard.
 */
export interface ListLeaderboardRecordsRequest {
  /**
   *  The ID of the leaderboard to list for.
   */
  leaderboard_id: string;
  /**
   *  One or more owners to retrieve records for.
   */
  owner_ids: string[];
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  A next or previous page cursor.
   */
  cursor: string;
  /**
   *  Expiry in seconds (since epoch) to begin fetching records from. Optional. 0 means from current time.
   */
  expiry?: number;
}

/**
 *  List realtime matches.
 */
export interface ListMatchesRequest {
  /**
   *  Limit the number of returned matches.
   */
  limit?: number;
  /**
   *  Authoritative or relayed matches.
   */
  authoritative?: boolean;
  /**
   *  Label filter.
   */
  label?: string;
  /**
   *  Minimum user count.
   */
  min_size?: number;
  /**
   *  Maximum user count.
   */
  max_size?: number;
  /**
   *  Arbitrary label query.
   */
  query?: string;
}

/**
 *  Get a list of unexpired notifications.
 */
export interface ListNotificationsRequest {
  /**
   *  The number of notifications to get. Between 1 and 100.
   */
  limit?: number;
  /**
   *  A cursor to page through notifications. May be cached by clients to get from point in time forwards.
   */
  cacheable_cursor: string;
}

/**
 *  List publicly readable storage objects in a given collection.
 */
export interface ListStorageObjectsRequest {
  /**
   *  ID of the user.
   */
  user_id: string;
  /**
   *  The collection which stores the object.
   */
  collection: string;
  /**
   *  The number of storage objects to list. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The cursor to page through results from.
   */
  cursor: string;
}

/**
 *  List tournament records from a given tournament around the owner.
 */
export interface ListTournamentRecordsAroundOwnerRequest {
  /**
   *  The ID of the tournament to list for.
   */
  tournament_id: string;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The owner to retrieve records around.
   */
  owner_id: string;
  /**
   *  Expiry in seconds (since epoch) to begin fetching records from.
   */
  expiry?: number;
}

/**
 *  List tournament records from a given tournament.
 */
export interface ListTournamentRecordsRequest {
  /**
   *  The ID of the tournament to list for.
   */
  tournament_id: string;
  /**
   *  One or more owners to retrieve records for.
   */
  owner_ids: string[];
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  A next or previous page cursor.
   */
  cursor: string;
  /**
   *  Expiry in seconds (since epoch) to begin fetching records from.
   */
  expiry?: number;
}

/**
 *  List active/upcoming tournaments based on given filters.
 */
export interface ListTournamentsRequest {
  /**
   *  The start of the categories to include. Defaults to 0.
   */
  category_start?: number;
  /**
   *  The end of the categories to include. Defaults to 128.
   */
  category_end?: number;
  /**
   *  The start time for tournaments. Defaults to epoch.
   */
  start_time?: number;
  /**
   *  The end time for tournaments. Defaults to +1 year from current Unix time.
   */
  end_time?: number;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  A next page cursor for listings (optional).
   */
  cursor: string;
}

/**
 *  List the groups a user is part of, and their relationship to each.
 */
export interface ListUserGroupsRequest {
  /**
   *  ID of the user.
   */
  user_id: string;
  /**
   *  Max number of records to return. Between 1 and 100.
   */
  limit?: number;
  /**
   *  The user group state to list.
   */
  state?: number;
  /**
   *  An optional next page cursor.
   */
  cursor: string;
}

/**
 *  Represents a realtime match.
 */
export interface Match {
  /**
   *  The ID of the match, can be used to join.
   */
  match_id: string;
  /**
   *  True if it's an server-managed authoritative match, false otherwise.
   */
  authoritative: boolean;
  /**
   *  Match label, if any.
   */
  label?: string;
  /**
   *  Current number of users in the match.
   */
  size: number;
}

/**
 *  A list of realtime matches.
 */
export interface MatchList {
  /**
   *  A number of matches corresponding to a list operation.
   */
  matches: Match[];
}

/**
 *  A notification in the server.
 */
export interface Notification {
  /**
   *  ID of the Notification.
   */
  id: string;
  /**
   *  Subject of the notification.
   */
  subject: string;
  /**
   *  Content of the notification in JSON.
   */
  content: string;
  /**
   *  Category code for this notification.
   */
  code: number;
  /**
   *  ID of the sender, if a user. Otherwise 'null'.
   */
  sender_id: string;
  /**
   *  The UNIX time when the notification was created.
   */
  create_time?: Date;
  /**
   *  True if this notification was persisted to the database.
   */
  persistent: boolean;
}

/**
 *  A collection of zero or more notifications.
 */
export interface NotificationList {
  /**
   *  Collection of notifications.
   */
  notifications: Notification[];
  /**
   *  Use this cursor to paginate notifications. Cache this to catch up to new notifications.
   */
  cacheable_cursor: string;
}

/**
 *  Promote a set of users in a group to the next role up.
 */
export interface PromoteGroupUsersRequest {
  /**
   *  The group ID to promote in.
   */
  group_id: string;
  /**
   *  The users to promote.
   */
  user_ids: string[];
}

/**
 *  Storage objects to get.
 */
export interface ReadStorageObjectId {
  /**
   *  The collection which stores the object.
   */
  collection: string;
  /**
   *  The key of the object within the collection.
   */
  key: string;
  /**
   *  The user owner of the object.
   */
  user_id: string;
}

/**
 *  Batch get storage objects.
 */
export interface ReadStorageObjectsRequest {
  /**
   *  Batch of storage objects.
   */
  object_ids: ReadStorageObjectId[];
}

/**
 *  Execute an Lua function on the server.
 */
export interface Rpc {
  /**
   *  The identifier of the function.
   */
  id: string;
  /**
   *  The payload of the function which must be a JSON object.
   */
  payload: string;
  /**
   *  The authentication key used when executed as a non-client HTTP request.
   */
  http_key: string;
}

/**
 *  A user's session used to authenticate messages.
 */
export interface Session {
  /**
   *  True if the corresponding account was just created, false otherwise.
   */
  created: boolean;
  /**
   *  Authentication credentials.
   */
  token: string;
}

/**
 *  An object within the storage engine.
 */
export interface StorageObject {
  /**
   *  The collection which stores the object.
   */
  collection: string;
  /**
   *  The key of the object within the collection.
   */
  key: string;
  /**
   *  The user owner of the object.
   */
  user_id: string;
  /**
   *  The value of the object.
   */
  value: string;
  /**
   *  The version hash of the object.
   */
  version: string;
  /**
   *  The read access permissions for the object.
   */
  permission_read: number;
  /**
   *  The write access permissions for the object.
   */
  permission_write: number;
  /**
   *  The UNIX time when the object was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the object was last updated.
   */
  update_time?: Date;
}

/**
 *  A storage acknowledgement.
 */
export interface StorageObjectAck {
  /**
   *  The collection which stores the object.
   */
  collection: string;
  /**
   *  The key of the object within the collection.
   */
  key: string;
  /**
   *  The version hash of the object.
   */
  version: string;
  /**
   *  The owner of the object.
   */
  user_id: string;
}

/**
 *  Batch of acknowledgements for the storage object write.
 */
export interface StorageObjectAcks {
  /**
   *  Batch of storage write acknowledgements.
   */
  acks: StorageObjectAck[];
}

/**
 *  Batch of storage objects.
 */
export interface StorageObjects {
  /**
   *  The batch of storage objects.
   */
  objects: StorageObject[];
}

/**
 *  List of storage objects.
 */
export interface StorageObjectList {
  /**
   *  The list of storage objects.
   */
  objects: StorageObject[];
  /**
   *  The cursor for the next page of results, if any.
   */
  cursor: string;
}

/**
 *  A tournament on the server.
 */
export interface Tournament {
  /**
   *  The ID of the tournament.
   */
  id: string;
  /**
   *  The title for the tournament.
   */
  title: string;
  /**
   *  The description of the tournament. May be blank.
   */
  description: string;
  /**
   *  The category of the tournament. e.g. "vip" could be category 1.
   */
  category: number;
  /**
   *  ASC or DESC sort mode of scores in the tournament.
   */
  sort_order: number;
  /**
   *  The current number of players in the tournament.
   */
  size: number;
  /**
   *  The maximum number of players for the tournament.
   */
  max_size: number;
  /**
   *  The maximum score updates allowed per player for the current tournament.
   */
  max_num_score: number;
  /**
   *  True if the tournament is active and can enter. A computed value.
   */
  can_enter: boolean;
  /**
   *  The UNIX time when the tournament stops being active until next reset. A computed value.
   */
  end_active: number;
  /**
   *  The UNIX time when the tournament is next playable. A computed value.
   */
  next_reset: number;
  /**
   *  Additional information stored as a JSON object.
   */
  metadata: string;
  /**
   *  The UNIX time when the tournament was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the tournament will start.
   */
  start_time?: Date;
  /**
   *  The UNIX time when the tournament will be stopped.
   */
  end_time?: Date;
  /**
   *  Duration of the tournament in seconds.
   */
  duration: number;
  /**
   *  The UNIX time when the tournament start being active. A computed value.
   */
  start_active: number;
}

/**
 *  A list of tournaments.
 */
export interface TournamentList {
  /**
   *  The list of tournaments returned.
   */
  tournaments: Tournament[];
  /**
   *  A pagination cursor (optional).
   */
  cursor: string;
}

/**
 *  A set of tournament records which may be part of a tournament records page or a batch of individual records.
 */
export interface TournamentRecordList {
  /**
   *  A list of tournament records.
   */
  records: LeaderboardRecord[];
  /**
   *  A batched set of tournament records belonging to specified owners.
   */
  owner_records: LeaderboardRecord[];
  /**
   *  The cursor to send when retireving the next page (optional).
   */
  next_cursor: string;
  /**
   *  The cursor to send when retrieving the previous page (optional).
   */
  prev_cursor: string;
}

/**
 *  Update a user's account details.
 */
export interface UpdateAccountRequest {
  /**
   *  The username of the user's account.
   */
  username?: string;
  /**
   *  The display name of the user.
   */
  display_name?: string;
  /**
   *  A URL for an avatar image.
   */
  avatar_url?: string;
  /**
   *  The language expected to be a tag which follows the BCP-47 spec.
   */
  lang_tag?: string;
  /**
   *  The location set by the user.
   */
  location?: string;
  /**
   *  The timezone set by the user.
   */
  timezone?: string;
}

/**
 *  Update fields in a given group.
 */
export interface UpdateGroupRequest {
  /**
   *  The ID of the group to update.
   */
  group_id: string;
  /**
   *  Name.
   */
  name?: string;
  /**
   *  Description string.
   */
  description?: string;
  /**
   *  Lang tag.
   */
  lang_tag?: string;
  /**
   *  Avatar URL.
   */
  avatar_url?: string;
  /**
   *  Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
   */
  open?: boolean;
}

/**
 *  A user in the server.
 */
export interface User {
  /**
   *  The id of the user's account.
   */
  id: string;
  /**
   *  The username of the user's account.
   */
  username: string;
  /**
   *  The display name of the user.
   */
  display_name: string;
  /**
   *  A URL for an avatar image.
   */
  avatar_url: string;
  /**
   *  The language expected to be a tag which follows the BCP-47 spec.
   */
  lang_tag: string;
  /**
   *  The location set by the user.
   */
  location: string;
  /**
   *  The timezone set by the user.
   */
  timezone: string;
  /**
   *  Additional information stored as a JSON object.
   */
  metadata: string;
  /**
   *  The Facebook id in the user's account.
   */
  facebook_id: string;
  /**
   *  The Google id in the user's account.
   */
  google_id: string;
  /**
   *  The Apple Game Center in of the user's account.
   */
  gamecenter_id: string;
  /**
   *  The Steam id in the user's account.
   */
  steam_id: string;
  /**
   *  Indicates whether the user is currently online.
   */
  online: boolean;
  /**
   *  Number of related edges to this user.
   */
  edge_count: number;
  /**
   *  The UNIX time when the user was created.
   */
  create_time?: Date;
  /**
   *  The UNIX time when the user was last updated.
   */
  update_time?: Date;
  /**
   *  The Facebook Instant Game id in the user's account.
   */
  facebook_instant_game_id: string;
}

/**
 *  A list of groups belonging to a user, along with the user's role in each group.
 */
export interface UserGroupList {
  /**
   *  Group-role pairs for a user.
   */
  user_groups: UserGroupList_UserGroup[];
  /**
   *  Cursor for the next page of results, if any.
   */
  cursor: string;
}

/**
 *  A single group-role pair.
 */
export interface UserGroupList_UserGroup {
  /**
   *  Group.
   */
  group?: Group;
  /**
   *  The user's relationship to the group.
   */
  state?: number;
}

/**
 *  A collection of zero or more users.
 */
export interface Users {
  /**
   *  The User objects.
   */
  users: User[];
}

/**
 *  A request to submit a score to a leaderboard.
 */
export interface WriteLeaderboardRecordRequest {
  /**
   *  The ID of the leaderboard to write to.
   */
  leaderboard_id: string;
  /**
   *  Record input.
   */
  record?: WriteLeaderboardRecordRequest_LeaderboardRecordWrite;
}

/**
 *  Record values to write.
 */
export interface WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
  /**
   *  The score value to submit.
   */
  score: number;
  /**
   *  An optional secondary value.
   */
  subscore: number;
  /**
   *  Optional record metadata.
   */
  metadata: string;
}

/**
 *  The object to store.
 */
export interface WriteStorageObject {
  /**
   *  The collection to store the object.
   */
  collection: string;
  /**
   *  The key for the object within the collection.
   */
  key: string;
  /**
   *  The value of the object.
   */
  value: string;
  /**
   *  The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
   */
  version: string;
  /**
   *  The read access permissions for the object.
   */
  permission_read?: number;
  /**
   *  The write access permissions for the object.
   */
  permission_write?: number;
}

/**
 *  Write objects to the storage engine.
 */
export interface WriteStorageObjectsRequest {
  /**
   *  The objects to store on the server.
   */
  objects: WriteStorageObject[];
}

/**
 *  A request to submit a score to a tournament.
 */
export interface WriteTournamentRecordRequest {
  /**
   *  The tournament ID to write the record for.
   */
  tournament_id: string;
  /**
   *  Record input.
   */
  record?: WriteTournamentRecordRequest_TournamentRecordWrite;
}

/**
 *  Record values to write.
 */
export interface WriteTournamentRecordRequest_TournamentRecordWrite {
  /**
   *  The score value to submit.
   */
  score: number;
  /**
   *  An optional secondary value.
   */
  subscore: number;
  /**
   *  A JSON object of additional properties (optional).
   */
  metadata: string;
}

const baseAccount: object = {
  wallet: "",
  email: "",
  custom_id: "",
};

const baseAccountCustom: object = {
  id: "",
};

const baseAccountCustom_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountDevice: object = {
  id: "",
};

const baseAccountDevice_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountEmail: object = {
  email: "",
  password: "",
};

const baseAccountEmail_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountFacebook: object = {
  token: "",
};

const baseAccountFacebook_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountFacebookInstantGame: object = {
  signed_player_info: "",
};

const baseAccountFacebookInstantGame_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountGameCenter: object = {
  player_id: "",
  bundle_id: "",
  timestamp_seconds: 0,
  salt: "",
  signature: "",
  public_key_url: "",
};

const baseAccountGameCenter_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountGoogle: object = {
  token: "",
};

const baseAccountGoogle_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAccountSteam: object = {
  token: "",
};

const baseAccountSteam_VarsEntry: object = {
  key: "",
  value: "",
};

const baseAddFriendsRequest: object = {
  ids: "",
  usernames: "",
};

const baseAddGroupUsersRequest: object = {
  group_id: "",
  user_ids: "",
};

const baseAuthenticateCustomRequest: object = {
  username: "",
};

const baseAuthenticateDeviceRequest: object = {
  username: "",
};

const baseAuthenticateEmailRequest: object = {
  username: "",
};

const baseAuthenticateFacebookRequest: object = {
  username: "",
};

const baseAuthenticateFacebookInstantGameRequest: object = {
  username: "",
};

const baseAuthenticateGameCenterRequest: object = {
  username: "",
};

const baseAuthenticateGoogleRequest: object = {
  username: "",
};

const baseAuthenticateSteamRequest: object = {
  username: "",
};

const baseBanGroupUsersRequest: object = {
  group_id: "",
  user_ids: "",
};

const baseBlockFriendsRequest: object = {
  ids: "",
  usernames: "",
};

const baseChannelMessage: object = {
  channel_id: "",
  message_id: "",
  sender_id: "",
  username: "",
  content: "",
  room_name: "",
  group_id: "",
  user_id_one: "",
  user_id_two: "",
};

const baseChannelMessageList: object = {
  next_cursor: "",
  prev_cursor: "",
};

const baseCreateGroupRequest: object = {
  name: "",
  description: "",
  lang_tag: "",
  avatar_url: "",
  open: false,
  max_count: 0,
};

const baseDeleteFriendsRequest: object = {
  ids: "",
  usernames: "",
};

const baseDeleteGroupRequest: object = {
  group_id: "",
};

const baseDeleteLeaderboardRecordRequest: object = {
  leaderboard_id: "",
};

const baseDeleteNotificationsRequest: object = {
  ids: "",
};

const baseDeleteStorageObjectId: object = {
  collection: "",
  key: "",
  version: "",
};

const baseDeleteStorageObjectsRequest: object = {
};

const baseEvent: object = {
  name: "",
  external: false,
};

const baseEvent_PropertiesEntry: object = {
  key: "",
  value: "",
};

const baseFriend: object = {
};

const baseFriendList: object = {
  cursor: "",
};

const baseGetUsersRequest: object = {
  ids: "",
  usernames: "",
  facebook_ids: "",
};

const baseGroup: object = {
  id: "",
  creator_id: "",
  name: "",
  description: "",
  lang_tag: "",
  metadata: "",
  avatar_url: "",
  edge_count: 0,
  max_count: 0,
};

const baseGroupList: object = {
  cursor: "",
};

const baseGroupUserList: object = {
  cursor: "",
};

const baseGroupUserList_GroupUser: object = {
};

const baseImportFacebookFriendsRequest: object = {
};

const baseJoinGroupRequest: object = {
  group_id: "",
};

const baseJoinTournamentRequest: object = {
  tournament_id: "",
};

const baseKickGroupUsersRequest: object = {
  group_id: "",
  user_ids: "",
};

const baseLeaderboardRecord: object = {
  leaderboard_id: "",
  owner_id: "",
  score: 0,
  subscore: 0,
  num_score: 0,
  metadata: "",
  rank: 0,
  max_num_score: 0,
};

const baseLeaderboardRecordList: object = {
  next_cursor: "",
  prev_cursor: "",
};

const baseLeaveGroupRequest: object = {
  group_id: "",
};

const baseLinkFacebookRequest: object = {
};

const baseListChannelMessagesRequest: object = {
  channel_id: "",
  cursor: "",
};

const baseListFriendsRequest: object = {
  cursor: "",
};

const baseListGroupsRequest: object = {
  name: "",
  cursor: "",
};

const baseListGroupUsersRequest: object = {
  group_id: "",
  cursor: "",
};

const baseListLeaderboardRecordsAroundOwnerRequest: object = {
  leaderboard_id: "",
  owner_id: "",
};

const baseListLeaderboardRecordsRequest: object = {
  leaderboard_id: "",
  owner_ids: "",
  cursor: "",
};

const baseListMatchesRequest: object = {
};

const baseListNotificationsRequest: object = {
  cacheable_cursor: "",
};

const baseListStorageObjectsRequest: object = {
  user_id: "",
  collection: "",
  cursor: "",
};

const baseListTournamentRecordsAroundOwnerRequest: object = {
  tournament_id: "",
  owner_id: "",
};

const baseListTournamentRecordsRequest: object = {
  tournament_id: "",
  owner_ids: "",
  cursor: "",
};

const baseListTournamentsRequest: object = {
  cursor: "",
};

const baseListUserGroupsRequest: object = {
  user_id: "",
  cursor: "",
};

const baseMatch: object = {
  match_id: "",
  authoritative: false,
  size: 0,
};

const baseMatchList: object = {
};

const baseNotification: object = {
  id: "",
  subject: "",
  content: "",
  code: 0,
  sender_id: "",
  persistent: false,
};

const baseNotificationList: object = {
  cacheable_cursor: "",
};

const basePromoteGroupUsersRequest: object = {
  group_id: "",
  user_ids: "",
};

const baseReadStorageObjectId: object = {
  collection: "",
  key: "",
  user_id: "",
};

const baseReadStorageObjectsRequest: object = {
};

const baseRpc: object = {
  id: "",
  payload: "",
  http_key: "",
};

const baseSession: object = {
  created: false,
  token: "",
};

const baseStorageObject: object = {
  collection: "",
  key: "",
  user_id: "",
  value: "",
  version: "",
  permission_read: 0,
  permission_write: 0,
};

const baseStorageObjectAck: object = {
  collection: "",
  key: "",
  version: "",
  user_id: "",
};

const baseStorageObjectAcks: object = {
};

const baseStorageObjects: object = {
};

const baseStorageObjectList: object = {
  cursor: "",
};

const baseTournament: object = {
  id: "",
  title: "",
  description: "",
  category: 0,
  sort_order: 0,
  size: 0,
  max_size: 0,
  max_num_score: 0,
  can_enter: false,
  end_active: 0,
  next_reset: 0,
  metadata: "",
  duration: 0,
  start_active: 0,
};

const baseTournamentList: object = {
  cursor: "",
};

const baseTournamentRecordList: object = {
  next_cursor: "",
  prev_cursor: "",
};

const baseUpdateAccountRequest: object = {
};

const baseUpdateGroupRequest: object = {
  group_id: "",
};

const baseUser: object = {
  id: "",
  username: "",
  display_name: "",
  avatar_url: "",
  lang_tag: "",
  location: "",
  timezone: "",
  metadata: "",
  facebook_id: "",
  google_id: "",
  gamecenter_id: "",
  steam_id: "",
  online: false,
  edge_count: 0,
  facebook_instant_game_id: "",
};

const baseUserGroupList: object = {
  cursor: "",
};

const baseUserGroupList_UserGroup: object = {
};

const baseUsers: object = {
};

const baseWriteLeaderboardRecordRequest: object = {
  leaderboard_id: "",
};

const baseWriteLeaderboardRecordRequest_LeaderboardRecordWrite: object = {
  score: 0,
  subscore: 0,
  metadata: "",
};

const baseWriteStorageObject: object = {
  collection: "",
  key: "",
  value: "",
  version: "",
};

const baseWriteStorageObjectsRequest: object = {
};

const baseWriteTournamentRecordRequest: object = {
  tournament_id: "",
};

const baseWriteTournamentRecordRequest_TournamentRecordWrite: object = {
  score: 0,
  subscore: 0,
  metadata: "",
};

function fromJsonTimestamp(o: any): Date {
  if (o instanceof Date) {
    return o;
  } else if (typeof o === "string") {
    return new Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function toTimestamp(date: Date): Timestamp {
  const seconds = date.getTime() / 1_000;
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = t.seconds * 1_000;
  millis += t.nanos / 1_000_000;
  return new Date(millis);
}

function longToNumber(long: Long) {
  if (long.gt(Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

/**  The friendship status.
 */
export const Friend_State = {
  /** FRIEND -  The user is a friend of the current user.
   */
  FRIEND: 0 as const,
  /** INVITE_SENT -  The current user has sent an invite to the user.
   */
  INVITE_SENT: 1 as const,
  /** INVITE_RECEIVED -  The current user has received an invite from this user.
   */
  INVITE_RECEIVED: 2 as const,
  /** BLOCKED -  The current user has blocked this user.
   */
  BLOCKED: 3 as const,
  UNRECOGNIZED: -1 as const,
  fromJSON(object: any): Friend_State {
    switch (object) {
      case 0:
      case "FRIEND":
        return Friend_State.FRIEND;
      case 1:
      case "INVITE_SENT":
        return Friend_State.INVITE_SENT;
      case 2:
      case "INVITE_RECEIVED":
        return Friend_State.INVITE_RECEIVED;
      case 3:
      case "BLOCKED":
        return Friend_State.BLOCKED;
      case -1:
      case "UNRECOGNIZED":
      default:
        return Friend_State.UNRECOGNIZED;
    }
  },
  toJSON(object: Friend_State): string {
    switch (object) {
      case Friend_State.FRIEND:
        return "FRIEND";
      case Friend_State.INVITE_SENT:
        return "INVITE_SENT";
      case Friend_State.INVITE_RECEIVED:
        return "INVITE_RECEIVED";
      case Friend_State.BLOCKED:
        return "BLOCKED";
      default:
        return "UNKNOWN";
    }
  },
}

export type Friend_State = 0 | 1 | 2 | 3 | -1;

/**  The group role status.
 */
export const GroupUserList_GroupUser_State = {
  /** SUPERADMIN -  The user is a superadmin with full control of the group.
   */
  SUPERADMIN: 0 as const,
  /** ADMIN -  The user is an admin with additional privileges.
   */
  ADMIN: 1 as const,
  /** MEMBER -  The user is a regular member.
   */
  MEMBER: 2 as const,
  /** JOIN_REQUEST -  The user has requested to join the group
   */
  JOIN_REQUEST: 3 as const,
  UNRECOGNIZED: -1 as const,
  fromJSON(object: any): GroupUserList_GroupUser_State {
    switch (object) {
      case 0:
      case "SUPERADMIN":
        return GroupUserList_GroupUser_State.SUPERADMIN;
      case 1:
      case "ADMIN":
        return GroupUserList_GroupUser_State.ADMIN;
      case 2:
      case "MEMBER":
        return GroupUserList_GroupUser_State.MEMBER;
      case 3:
      case "JOIN_REQUEST":
        return GroupUserList_GroupUser_State.JOIN_REQUEST;
      case -1:
      case "UNRECOGNIZED":
      default:
        return GroupUserList_GroupUser_State.UNRECOGNIZED;
    }
  },
  toJSON(object: GroupUserList_GroupUser_State): string {
    switch (object) {
      case GroupUserList_GroupUser_State.SUPERADMIN:
        return "SUPERADMIN";
      case GroupUserList_GroupUser_State.ADMIN:
        return "ADMIN";
      case GroupUserList_GroupUser_State.MEMBER:
        return "MEMBER";
      case GroupUserList_GroupUser_State.JOIN_REQUEST:
        return "JOIN_REQUEST";
      default:
        return "UNKNOWN";
    }
  },
}

export type GroupUserList_GroupUser_State = 0 | 1 | 2 | 3 | -1;

/**  The group role status.
 */
export const UserGroupList_UserGroup_State = {
  /** SUPERADMIN -  The user is a superadmin with full control of the group.
   */
  SUPERADMIN: 0 as const,
  /** ADMIN -  The user is an admin with additional privileges.
   */
  ADMIN: 1 as const,
  /** MEMBER -  The user is a regular member.
   */
  MEMBER: 2 as const,
  /** JOIN_REQUEST -  The user has requested to join the group
   */
  JOIN_REQUEST: 3 as const,
  UNRECOGNIZED: -1 as const,
  fromJSON(object: any): UserGroupList_UserGroup_State {
    switch (object) {
      case 0:
      case "SUPERADMIN":
        return UserGroupList_UserGroup_State.SUPERADMIN;
      case 1:
      case "ADMIN":
        return UserGroupList_UserGroup_State.ADMIN;
      case 2:
      case "MEMBER":
        return UserGroupList_UserGroup_State.MEMBER;
      case 3:
      case "JOIN_REQUEST":
        return UserGroupList_UserGroup_State.JOIN_REQUEST;
      case -1:
      case "UNRECOGNIZED":
      default:
        return UserGroupList_UserGroup_State.UNRECOGNIZED;
    }
  },
  toJSON(object: UserGroupList_UserGroup_State): string {
    switch (object) {
      case UserGroupList_UserGroup_State.SUPERADMIN:
        return "SUPERADMIN";
      case UserGroupList_UserGroup_State.ADMIN:
        return "ADMIN";
      case UserGroupList_UserGroup_State.MEMBER:
        return "MEMBER";
      case UserGroupList_UserGroup_State.JOIN_REQUEST:
        return "JOIN_REQUEST";
      default:
        return "UNKNOWN";
    }
  },
}

export type UserGroupList_UserGroup_State = 0 | 1 | 2 | 3 | -1;

export const Account = {
  encode(message: Account, writer: Writer = Writer.create()): Writer {
    if (message.user !== undefined && message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.wallet);
    writer.uint32(26).string(message.email);
    for (const v of message.devices) {
      AccountDevice.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    writer.uint32(42).string(message.custom_id);
    if (message.verify_time !== undefined && message.verify_time !== undefined) {
      Timestamp.encode(toTimestamp(message.verify_time), writer.uint32(50).fork()).ldelim();
    }
    if (message.disable_time !== undefined && message.disable_time !== undefined) {
      Timestamp.encode(toTimestamp(message.disable_time), writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Account {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccount } as Account;
    message.devices = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = User.decode(reader, reader.uint32());
          break;
        case 2:
          message.wallet = reader.string();
          break;
        case 3:
          message.email = reader.string();
          break;
        case 4:
          message.devices.push(AccountDevice.decode(reader, reader.uint32()));
          break;
        case 5:
          message.custom_id = reader.string();
          break;
        case 6:
          message.verify_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 7:
          message.disable_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Account {
    const message = { ...baseAccount } as Account;
    message.devices = [];
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromJSON(object.user);
    }
    if (object.wallet !== undefined && object.wallet !== null) {
      message.wallet = String(object.wallet);
    }
    if (object.email !== undefined && object.email !== null) {
      message.email = String(object.email);
    }
    if (object.devices !== undefined && object.devices !== null) {
      for (const e of object.devices) {
        message.devices.push(AccountDevice.fromJSON(e));
      }
    }
    if (object.custom_id !== undefined && object.custom_id !== null) {
      message.custom_id = String(object.custom_id);
    }
    if (object.verify_time !== undefined && object.verify_time !== null) {
      message.verify_time = fromJsonTimestamp(object.verify_time);
    }
    if (object.disable_time !== undefined && object.disable_time !== null) {
      message.disable_time = fromJsonTimestamp(object.disable_time);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Account>): Account {
    const message = { ...baseAccount } as Account;
    message.devices = [];
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromPartial(object.user);
    }
    if (object.wallet !== undefined && object.wallet !== null) {
      message.wallet = object.wallet;
    }
    if (object.email !== undefined && object.email !== null) {
      message.email = object.email;
    }
    if (object.devices !== undefined && object.devices !== null) {
      for (const e of object.devices) {
        message.devices.push(AccountDevice.fromPartial(e));
      }
    }
    if (object.custom_id !== undefined && object.custom_id !== null) {
      message.custom_id = object.custom_id;
    }
    if (object.verify_time !== undefined && object.verify_time !== null) {
      message.verify_time = object.verify_time;
    }
    if (object.disable_time !== undefined && object.disable_time !== null) {
      message.disable_time = object.disable_time;
    }
    return message;
  },
  toJSON(message: Account): unknown {
    const obj: any = {};
    obj.user = message.user ? User.toJSON(message.user) : undefined;
    obj.wallet = message.wallet || "";
    obj.email = message.email || "";
    if (message.devices) {
      obj.devices = message.devices.map(e => e ? AccountDevice.toJSON(e) : undefined);
    } else {
      obj.devices = [];
    }
    obj.custom_id = message.custom_id || "";
    obj.verify_time = message.verify_time !== undefined ? message.verify_time.toISOString() : null;
    obj.disable_time = message.disable_time !== undefined ? message.disable_time.toISOString() : null;
    return obj;
  },
};

export const AccountCustom = {
  encode(message: AccountCustom, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountCustom_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountCustom {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountCustom } as AccountCustom;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          const entry2 = AccountCustom_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountCustom {
    const message = { ...baseAccountCustom } as AccountCustom;
    message.vars = {};
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountCustom>): AccountCustom {
    const message = { ...baseAccountCustom } as AccountCustom;
    message.vars = {};
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountCustom): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountCustom_VarsEntry = {
  encode(message: AccountCustom_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountCustom_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountCustom_VarsEntry } as AccountCustom_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountCustom_VarsEntry {
    const message = { ...baseAccountCustom_VarsEntry } as AccountCustom_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountCustom_VarsEntry>): AccountCustom_VarsEntry {
    const message = { ...baseAccountCustom_VarsEntry } as AccountCustom_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountCustom_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountDevice = {
  encode(message: AccountDevice, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountDevice_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountDevice {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountDevice } as AccountDevice;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          const entry2 = AccountDevice_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountDevice {
    const message = { ...baseAccountDevice } as AccountDevice;
    message.vars = {};
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountDevice>): AccountDevice {
    const message = { ...baseAccountDevice } as AccountDevice;
    message.vars = {};
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountDevice): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountDevice_VarsEntry = {
  encode(message: AccountDevice_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountDevice_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountDevice_VarsEntry } as AccountDevice_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountDevice_VarsEntry {
    const message = { ...baseAccountDevice_VarsEntry } as AccountDevice_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountDevice_VarsEntry>): AccountDevice_VarsEntry {
    const message = { ...baseAccountDevice_VarsEntry } as AccountDevice_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountDevice_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountEmail = {
  encode(message: AccountEmail, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.email);
    writer.uint32(18).string(message.password);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountEmail_VarsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountEmail {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountEmail } as AccountEmail;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.email = reader.string();
          break;
        case 2:
          message.password = reader.string();
          break;
        case 3:
          const entry3 = AccountEmail_VarsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.vars[entry3.key] = entry3.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountEmail {
    const message = { ...baseAccountEmail } as AccountEmail;
    message.vars = {};
    if (object.email !== undefined && object.email !== null) {
      message.email = String(object.email);
    }
    if (object.password !== undefined && object.password !== null) {
      message.password = String(object.password);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountEmail>): AccountEmail {
    const message = { ...baseAccountEmail } as AccountEmail;
    message.vars = {};
    if (object.email !== undefined && object.email !== null) {
      message.email = object.email;
    }
    if (object.password !== undefined && object.password !== null) {
      message.password = object.password;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountEmail): unknown {
    const obj: any = {};
    obj.email = message.email || "";
    obj.password = message.password || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountEmail_VarsEntry = {
  encode(message: AccountEmail_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountEmail_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountEmail_VarsEntry } as AccountEmail_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountEmail_VarsEntry {
    const message = { ...baseAccountEmail_VarsEntry } as AccountEmail_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountEmail_VarsEntry>): AccountEmail_VarsEntry {
    const message = { ...baseAccountEmail_VarsEntry } as AccountEmail_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountEmail_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountFacebook = {
  encode(message: AccountFacebook, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.token);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountFacebook_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountFacebook {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountFacebook } as AccountFacebook;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          const entry2 = AccountFacebook_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountFacebook {
    const message = { ...baseAccountFacebook } as AccountFacebook;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = String(object.token);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountFacebook>): AccountFacebook {
    const message = { ...baseAccountFacebook } as AccountFacebook;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = object.token;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountFacebook): unknown {
    const obj: any = {};
    obj.token = message.token || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountFacebook_VarsEntry = {
  encode(message: AccountFacebook_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountFacebook_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountFacebook_VarsEntry } as AccountFacebook_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountFacebook_VarsEntry {
    const message = { ...baseAccountFacebook_VarsEntry } as AccountFacebook_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountFacebook_VarsEntry>): AccountFacebook_VarsEntry {
    const message = { ...baseAccountFacebook_VarsEntry } as AccountFacebook_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountFacebook_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountFacebookInstantGame = {
  encode(message: AccountFacebookInstantGame, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.signed_player_info);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountFacebookInstantGame_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountFacebookInstantGame {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountFacebookInstantGame } as AccountFacebookInstantGame;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.signed_player_info = reader.string();
          break;
        case 2:
          const entry2 = AccountFacebookInstantGame_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountFacebookInstantGame {
    const message = { ...baseAccountFacebookInstantGame } as AccountFacebookInstantGame;
    message.vars = {};
    if (object.signed_player_info !== undefined && object.signed_player_info !== null) {
      message.signed_player_info = String(object.signed_player_info);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountFacebookInstantGame>): AccountFacebookInstantGame {
    const message = { ...baseAccountFacebookInstantGame } as AccountFacebookInstantGame;
    message.vars = {};
    if (object.signed_player_info !== undefined && object.signed_player_info !== null) {
      message.signed_player_info = object.signed_player_info;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountFacebookInstantGame): unknown {
    const obj: any = {};
    obj.signed_player_info = message.signed_player_info || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountFacebookInstantGame_VarsEntry = {
  encode(message: AccountFacebookInstantGame_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountFacebookInstantGame_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountFacebookInstantGame_VarsEntry } as AccountFacebookInstantGame_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountFacebookInstantGame_VarsEntry {
    const message = { ...baseAccountFacebookInstantGame_VarsEntry } as AccountFacebookInstantGame_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountFacebookInstantGame_VarsEntry>): AccountFacebookInstantGame_VarsEntry {
    const message = { ...baseAccountFacebookInstantGame_VarsEntry } as AccountFacebookInstantGame_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountFacebookInstantGame_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountGameCenter = {
  encode(message: AccountGameCenter, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.player_id);
    writer.uint32(18).string(message.bundle_id);
    writer.uint32(24).int64(message.timestamp_seconds);
    writer.uint32(34).string(message.salt);
    writer.uint32(42).string(message.signature);
    writer.uint32(50).string(message.public_key_url);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountGameCenter_VarsEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountGameCenter {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountGameCenter } as AccountGameCenter;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.player_id = reader.string();
          break;
        case 2:
          message.bundle_id = reader.string();
          break;
        case 3:
          message.timestamp_seconds = longToNumber(reader.int64() as Long);
          break;
        case 4:
          message.salt = reader.string();
          break;
        case 5:
          message.signature = reader.string();
          break;
        case 6:
          message.public_key_url = reader.string();
          break;
        case 7:
          const entry7 = AccountGameCenter_VarsEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.vars[entry7.key] = entry7.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountGameCenter {
    const message = { ...baseAccountGameCenter } as AccountGameCenter;
    message.vars = {};
    if (object.player_id !== undefined && object.player_id !== null) {
      message.player_id = String(object.player_id);
    }
    if (object.bundle_id !== undefined && object.bundle_id !== null) {
      message.bundle_id = String(object.bundle_id);
    }
    if (object.timestamp_seconds !== undefined && object.timestamp_seconds !== null) {
      message.timestamp_seconds = Number(object.timestamp_seconds);
    }
    if (object.salt !== undefined && object.salt !== null) {
      message.salt = String(object.salt);
    }
    if (object.signature !== undefined && object.signature !== null) {
      message.signature = String(object.signature);
    }
    if (object.public_key_url !== undefined && object.public_key_url !== null) {
      message.public_key_url = String(object.public_key_url);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountGameCenter>): AccountGameCenter {
    const message = { ...baseAccountGameCenter } as AccountGameCenter;
    message.vars = {};
    if (object.player_id !== undefined && object.player_id !== null) {
      message.player_id = object.player_id;
    }
    if (object.bundle_id !== undefined && object.bundle_id !== null) {
      message.bundle_id = object.bundle_id;
    }
    if (object.timestamp_seconds !== undefined && object.timestamp_seconds !== null) {
      message.timestamp_seconds = object.timestamp_seconds;
    }
    if (object.salt !== undefined && object.salt !== null) {
      message.salt = object.salt;
    }
    if (object.signature !== undefined && object.signature !== null) {
      message.signature = object.signature;
    }
    if (object.public_key_url !== undefined && object.public_key_url !== null) {
      message.public_key_url = object.public_key_url;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountGameCenter): unknown {
    const obj: any = {};
    obj.player_id = message.player_id || "";
    obj.bundle_id = message.bundle_id || "";
    obj.timestamp_seconds = message.timestamp_seconds || 0;
    obj.salt = message.salt || "";
    obj.signature = message.signature || "";
    obj.public_key_url = message.public_key_url || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountGameCenter_VarsEntry = {
  encode(message: AccountGameCenter_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountGameCenter_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountGameCenter_VarsEntry } as AccountGameCenter_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountGameCenter_VarsEntry {
    const message = { ...baseAccountGameCenter_VarsEntry } as AccountGameCenter_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountGameCenter_VarsEntry>): AccountGameCenter_VarsEntry {
    const message = { ...baseAccountGameCenter_VarsEntry } as AccountGameCenter_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountGameCenter_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountGoogle = {
  encode(message: AccountGoogle, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.token);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountGoogle_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountGoogle {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountGoogle } as AccountGoogle;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          const entry2 = AccountGoogle_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountGoogle {
    const message = { ...baseAccountGoogle } as AccountGoogle;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = String(object.token);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountGoogle>): AccountGoogle {
    const message = { ...baseAccountGoogle } as AccountGoogle;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = object.token;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountGoogle): unknown {
    const obj: any = {};
    obj.token = message.token || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountGoogle_VarsEntry = {
  encode(message: AccountGoogle_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountGoogle_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountGoogle_VarsEntry } as AccountGoogle_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountGoogle_VarsEntry {
    const message = { ...baseAccountGoogle_VarsEntry } as AccountGoogle_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountGoogle_VarsEntry>): AccountGoogle_VarsEntry {
    const message = { ...baseAccountGoogle_VarsEntry } as AccountGoogle_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountGoogle_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AccountSteam = {
  encode(message: AccountSteam, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.token);
    Object.entries(message.vars).forEach(([key, value]) => {
      AccountSteam_VarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountSteam {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountSteam } as AccountSteam;
    message.vars = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.token = reader.string();
          break;
        case 2:
          const entry2 = AccountSteam_VarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.vars[entry2.key] = entry2.value;
          }
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountSteam {
    const message = { ...baseAccountSteam } as AccountSteam;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = String(object.token);
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        message.vars[key] = String(value);
      })
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountSteam>): AccountSteam {
    const message = { ...baseAccountSteam } as AccountSteam;
    message.vars = {};
    if (object.token !== undefined && object.token !== null) {
      message.token = object.token;
    }
    if (object.vars !== undefined && object.vars !== null) {
      Object.entries(object.vars).forEach(([key, value]) => {
        if (value !== undefined) {
          message.vars[key] = String(value);
        }
      })
    }
    return message;
  },
  toJSON(message: AccountSteam): unknown {
    const obj: any = {};
    obj.token = message.token || "";
    obj.vars = message.vars || undefined;
    return obj;
  },
};

export const AccountSteam_VarsEntry = {
  encode(message: AccountSteam_VarsEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AccountSteam_VarsEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAccountSteam_VarsEntry } as AccountSteam_VarsEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AccountSteam_VarsEntry {
    const message = { ...baseAccountSteam_VarsEntry } as AccountSteam_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AccountSteam_VarsEntry>): AccountSteam_VarsEntry {
    const message = { ...baseAccountSteam_VarsEntry } as AccountSteam_VarsEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: AccountSteam_VarsEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const AddFriendsRequest = {
  encode(message: AddFriendsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AddFriendsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAddFriendsRequest } as AddFriendsRequest;
    message.ids = [];
    message.usernames = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids.push(reader.string());
          break;
        case 2:
          message.usernames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AddFriendsRequest {
    const message = { ...baseAddFriendsRequest } as AddFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(String(e));
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<AddFriendsRequest>): AddFriendsRequest {
    const message = { ...baseAddFriendsRequest } as AddFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(e);
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(e);
      }
    }
    return message;
  },
  toJSON(message: AddFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids) {
      obj.ids = message.ids.map(e => e || "");
    } else {
      obj.ids = [];
    }
    if (message.usernames) {
      obj.usernames = message.usernames.map(e => e || "");
    } else {
      obj.usernames = [];
    }
    return obj;
  },
};

export const AddGroupUsersRequest = {
  encode(message: AddGroupUsersRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AddGroupUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAddGroupUsersRequest } as AddGroupUsersRequest;
    message.user_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.user_ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AddGroupUsersRequest {
    const message = { ...baseAddGroupUsersRequest } as AddGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<AddGroupUsersRequest>): AddGroupUsersRequest {
    const message = { ...baseAddGroupUsersRequest } as AddGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: AddGroupUsersRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    if (message.user_ids) {
      obj.user_ids = message.user_ids.map(e => e || "");
    } else {
      obj.user_ids = [];
    }
    return obj;
  },
};

export const AuthenticateCustomRequest = {
  encode(message: AuthenticateCustomRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountCustom.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateCustomRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateCustomRequest } as AuthenticateCustomRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountCustom.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateCustomRequest {
    const message = { ...baseAuthenticateCustomRequest } as AuthenticateCustomRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountCustom.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateCustomRequest>): AuthenticateCustomRequest {
    const message = { ...baseAuthenticateCustomRequest } as AuthenticateCustomRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountCustom.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateCustomRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountCustom.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateDeviceRequest = {
  encode(message: AuthenticateDeviceRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountDevice.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateDeviceRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateDeviceRequest } as AuthenticateDeviceRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountDevice.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateDeviceRequest {
    const message = { ...baseAuthenticateDeviceRequest } as AuthenticateDeviceRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountDevice.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateDeviceRequest>): AuthenticateDeviceRequest {
    const message = { ...baseAuthenticateDeviceRequest } as AuthenticateDeviceRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountDevice.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateDeviceRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountDevice.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateEmailRequest = {
  encode(message: AuthenticateEmailRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountEmail.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateEmailRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateEmailRequest } as AuthenticateEmailRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountEmail.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateEmailRequest {
    const message = { ...baseAuthenticateEmailRequest } as AuthenticateEmailRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountEmail.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateEmailRequest>): AuthenticateEmailRequest {
    const message = { ...baseAuthenticateEmailRequest } as AuthenticateEmailRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountEmail.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateEmailRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountEmail.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateFacebookRequest = {
  encode(message: AuthenticateFacebookRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    if (message.sync !== undefined && message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateFacebookRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateFacebookRequest } as AuthenticateFacebookRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountFacebook.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        case 4:
          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateFacebookRequest {
    const message = { ...baseAuthenticateFacebookRequest } as AuthenticateFacebookRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    if (object.sync !== undefined && object.sync !== null) {
      message.sync = Boolean(object.sync);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateFacebookRequest>): AuthenticateFacebookRequest {
    const message = { ...baseAuthenticateFacebookRequest } as AuthenticateFacebookRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    if (object.sync !== undefined && object.sync !== null) {
      message.sync = object.sync;
    }
    return message;
  },
  toJSON(message: AuthenticateFacebookRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    obj.sync = message.sync || undefined;
    return obj;
  },
};

export const AuthenticateFacebookInstantGameRequest = {
  encode(message: AuthenticateFacebookInstantGameRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountFacebookInstantGame.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateFacebookInstantGameRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateFacebookInstantGameRequest } as AuthenticateFacebookInstantGameRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountFacebookInstantGame.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateFacebookInstantGameRequest {
    const message = { ...baseAuthenticateFacebookInstantGameRequest } as AuthenticateFacebookInstantGameRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebookInstantGame.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateFacebookInstantGameRequest>): AuthenticateFacebookInstantGameRequest {
    const message = { ...baseAuthenticateFacebookInstantGameRequest } as AuthenticateFacebookInstantGameRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebookInstantGame.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateFacebookInstantGameRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountFacebookInstantGame.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateGameCenterRequest = {
  encode(message: AuthenticateGameCenterRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountGameCenter.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateGameCenterRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateGameCenterRequest } as AuthenticateGameCenterRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountGameCenter.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateGameCenterRequest {
    const message = { ...baseAuthenticateGameCenterRequest } as AuthenticateGameCenterRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountGameCenter.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateGameCenterRequest>): AuthenticateGameCenterRequest {
    const message = { ...baseAuthenticateGameCenterRequest } as AuthenticateGameCenterRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountGameCenter.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateGameCenterRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountGameCenter.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateGoogleRequest = {
  encode(message: AuthenticateGoogleRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountGoogle.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateGoogleRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateGoogleRequest } as AuthenticateGoogleRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountGoogle.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateGoogleRequest {
    const message = { ...baseAuthenticateGoogleRequest } as AuthenticateGoogleRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountGoogle.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateGoogleRequest>): AuthenticateGoogleRequest {
    const message = { ...baseAuthenticateGoogleRequest } as AuthenticateGoogleRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountGoogle.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateGoogleRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountGoogle.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const AuthenticateSteamRequest = {
  encode(message: AuthenticateSteamRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountSteam.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.create !== undefined && message.create !== undefined) {
      BoolValue.encode({ value: message.create! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.username);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): AuthenticateSteamRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseAuthenticateSteamRequest } as AuthenticateSteamRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountSteam.decode(reader, reader.uint32());
          break;
        case 2:
          message.create = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.username = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): AuthenticateSteamRequest {
    const message = { ...baseAuthenticateSteamRequest } as AuthenticateSteamRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountSteam.fromJSON(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = Boolean(object.create);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    return message;
  },
  fromPartial(object: DeepPartial<AuthenticateSteamRequest>): AuthenticateSteamRequest {
    const message = { ...baseAuthenticateSteamRequest } as AuthenticateSteamRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountSteam.fromPartial(object.account);
    }
    if (object.create !== undefined && object.create !== null) {
      message.create = object.create;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    return message;
  },
  toJSON(message: AuthenticateSteamRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountSteam.toJSON(message.account) : undefined;
    obj.create = message.create || undefined;
    obj.username = message.username || "";
    return obj;
  },
};

export const BanGroupUsersRequest = {
  encode(message: BanGroupUsersRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): BanGroupUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseBanGroupUsersRequest } as BanGroupUsersRequest;
    message.user_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.user_ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): BanGroupUsersRequest {
    const message = { ...baseBanGroupUsersRequest } as BanGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<BanGroupUsersRequest>): BanGroupUsersRequest {
    const message = { ...baseBanGroupUsersRequest } as BanGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: BanGroupUsersRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    if (message.user_ids) {
      obj.user_ids = message.user_ids.map(e => e || "");
    } else {
      obj.user_ids = [];
    }
    return obj;
  },
};

export const BlockFriendsRequest = {
  encode(message: BlockFriendsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): BlockFriendsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseBlockFriendsRequest } as BlockFriendsRequest;
    message.ids = [];
    message.usernames = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids.push(reader.string());
          break;
        case 2:
          message.usernames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): BlockFriendsRequest {
    const message = { ...baseBlockFriendsRequest } as BlockFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(String(e));
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<BlockFriendsRequest>): BlockFriendsRequest {
    const message = { ...baseBlockFriendsRequest } as BlockFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(e);
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(e);
      }
    }
    return message;
  },
  toJSON(message: BlockFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids) {
      obj.ids = message.ids.map(e => e || "");
    } else {
      obj.ids = [];
    }
    if (message.usernames) {
      obj.usernames = message.usernames.map(e => e || "");
    } else {
      obj.usernames = [];
    }
    return obj;
  },
};

export const ChannelMessage = {
  encode(message: ChannelMessage, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.channel_id);
    writer.uint32(18).string(message.message_id);
    if (message.code !== undefined && message.code !== undefined) {
      Int32Value.encode({ value: message.code! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.sender_id);
    writer.uint32(42).string(message.username);
    writer.uint32(50).string(message.content);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(58).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.persistent !== undefined && message.persistent !== undefined) {
      BoolValue.encode({ value: message.persistent! }, writer.uint32(74).fork()).ldelim();
    }
    writer.uint32(82).string(message.room_name);
    writer.uint32(90).string(message.group_id);
    writer.uint32(98).string(message.user_id_one);
    writer.uint32(106).string(message.user_id_two);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ChannelMessage {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseChannelMessage } as ChannelMessage;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channel_id = reader.string();
          break;
        case 2:
          message.message_id = reader.string();
          break;
        case 3:
          message.code = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.sender_id = reader.string();
          break;
        case 5:
          message.username = reader.string();
          break;
        case 6:
          message.content = reader.string();
          break;
        case 7:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 8:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 9:
          message.persistent = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 10:
          message.room_name = reader.string();
          break;
        case 11:
          message.group_id = reader.string();
          break;
        case 12:
          message.user_id_one = reader.string();
          break;
        case 13:
          message.user_id_two = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ChannelMessage {
    const message = { ...baseChannelMessage } as ChannelMessage;
    if (object.channel_id !== undefined && object.channel_id !== null) {
      message.channel_id = String(object.channel_id);
    }
    if (object.message_id !== undefined && object.message_id !== null) {
      message.message_id = String(object.message_id);
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = Number(object.code);
    }
    if (object.sender_id !== undefined && object.sender_id !== null) {
      message.sender_id = String(object.sender_id);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    if (object.content !== undefined && object.content !== null) {
      message.content = String(object.content);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    if (object.persistent !== undefined && object.persistent !== null) {
      message.persistent = Boolean(object.persistent);
    }
    if (object.room_name !== undefined && object.room_name !== null) {
      message.room_name = String(object.room_name);
    }
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.user_id_one !== undefined && object.user_id_one !== null) {
      message.user_id_one = String(object.user_id_one);
    }
    if (object.user_id_two !== undefined && object.user_id_two !== null) {
      message.user_id_two = String(object.user_id_two);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ChannelMessage>): ChannelMessage {
    const message = { ...baseChannelMessage } as ChannelMessage;
    if (object.channel_id !== undefined && object.channel_id !== null) {
      message.channel_id = object.channel_id;
    }
    if (object.message_id !== undefined && object.message_id !== null) {
      message.message_id = object.message_id;
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = object.code;
    }
    if (object.sender_id !== undefined && object.sender_id !== null) {
      message.sender_id = object.sender_id;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    if (object.content !== undefined && object.content !== null) {
      message.content = object.content;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    if (object.persistent !== undefined && object.persistent !== null) {
      message.persistent = object.persistent;
    }
    if (object.room_name !== undefined && object.room_name !== null) {
      message.room_name = object.room_name;
    }
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.user_id_one !== undefined && object.user_id_one !== null) {
      message.user_id_one = object.user_id_one;
    }
    if (object.user_id_two !== undefined && object.user_id_two !== null) {
      message.user_id_two = object.user_id_two;
    }
    return message;
  },
  toJSON(message: ChannelMessage): unknown {
    const obj: any = {};
    obj.channel_id = message.channel_id || "";
    obj.message_id = message.message_id || "";
    obj.code = message.code || undefined;
    obj.sender_id = message.sender_id || "";
    obj.username = message.username || "";
    obj.content = message.content || "";
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    obj.persistent = message.persistent || undefined;
    obj.room_name = message.room_name || "";
    obj.group_id = message.group_id || "";
    obj.user_id_one = message.user_id_one || "";
    obj.user_id_two = message.user_id_two || "";
    return obj;
  },
};

export const ChannelMessageList = {
  encode(message: ChannelMessageList, writer: Writer = Writer.create()): Writer {
    for (const v of message.messages) {
      ChannelMessage.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.next_cursor);
    writer.uint32(26).string(message.prev_cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ChannelMessageList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseChannelMessageList } as ChannelMessageList;
    message.messages = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.messages.push(ChannelMessage.decode(reader, reader.uint32()));
          break;
        case 2:
          message.next_cursor = reader.string();
          break;
        case 3:
          message.prev_cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ChannelMessageList {
    const message = { ...baseChannelMessageList } as ChannelMessageList;
    message.messages = [];
    if (object.messages !== undefined && object.messages !== null) {
      for (const e of object.messages) {
        message.messages.push(ChannelMessage.fromJSON(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = String(object.next_cursor);
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = String(object.prev_cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ChannelMessageList>): ChannelMessageList {
    const message = { ...baseChannelMessageList } as ChannelMessageList;
    message.messages = [];
    if (object.messages !== undefined && object.messages !== null) {
      for (const e of object.messages) {
        message.messages.push(ChannelMessage.fromPartial(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = object.next_cursor;
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = object.prev_cursor;
    }
    return message;
  },
  toJSON(message: ChannelMessageList): unknown {
    const obj: any = {};
    if (message.messages) {
      obj.messages = message.messages.map(e => e ? ChannelMessage.toJSON(e) : undefined);
    } else {
      obj.messages = [];
    }
    obj.next_cursor = message.next_cursor || "";
    obj.prev_cursor = message.prev_cursor || "";
    return obj;
  },
};

export const CreateGroupRequest = {
  encode(message: CreateGroupRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.name);
    writer.uint32(18).string(message.description);
    writer.uint32(26).string(message.lang_tag);
    writer.uint32(34).string(message.avatar_url);
    writer.uint32(40).bool(message.open);
    writer.uint32(48).int32(message.max_count);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): CreateGroupRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseCreateGroupRequest } as CreateGroupRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.description = reader.string();
          break;
        case 3:
          message.lang_tag = reader.string();
          break;
        case 4:
          message.avatar_url = reader.string();
          break;
        case 5:
          message.open = reader.bool();
          break;
        case 6:
          message.max_count = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): CreateGroupRequest {
    const message = { ...baseCreateGroupRequest } as CreateGroupRequest;
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = String(object.description);
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = String(object.lang_tag);
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = String(object.avatar_url);
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = Boolean(object.open);
    }
    if (object.max_count !== undefined && object.max_count !== null) {
      message.max_count = Number(object.max_count);
    }
    return message;
  },
  fromPartial(object: DeepPartial<CreateGroupRequest>): CreateGroupRequest {
    const message = { ...baseCreateGroupRequest } as CreateGroupRequest;
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = object.description;
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = object.lang_tag;
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = object.avatar_url;
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = object.open;
    }
    if (object.max_count !== undefined && object.max_count !== null) {
      message.max_count = object.max_count;
    }
    return message;
  },
  toJSON(message: CreateGroupRequest): unknown {
    const obj: any = {};
    obj.name = message.name || "";
    obj.description = message.description || "";
    obj.lang_tag = message.lang_tag || "";
    obj.avatar_url = message.avatar_url || "";
    obj.open = message.open || false;
    obj.max_count = message.max_count || 0;
    return obj;
  },
};

export const DeleteFriendsRequest = {
  encode(message: DeleteFriendsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteFriendsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteFriendsRequest } as DeleteFriendsRequest;
    message.ids = [];
    message.usernames = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids.push(reader.string());
          break;
        case 2:
          message.usernames.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteFriendsRequest {
    const message = { ...baseDeleteFriendsRequest } as DeleteFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(String(e));
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteFriendsRequest>): DeleteFriendsRequest {
    const message = { ...baseDeleteFriendsRequest } as DeleteFriendsRequest;
    message.ids = [];
    message.usernames = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(e);
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(e);
      }
    }
    return message;
  },
  toJSON(message: DeleteFriendsRequest): unknown {
    const obj: any = {};
    if (message.ids) {
      obj.ids = message.ids.map(e => e || "");
    } else {
      obj.ids = [];
    }
    if (message.usernames) {
      obj.usernames = message.usernames.map(e => e || "");
    } else {
      obj.usernames = [];
    }
    return obj;
  },
};

export const DeleteGroupRequest = {
  encode(message: DeleteGroupRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteGroupRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteGroupRequest } as DeleteGroupRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteGroupRequest {
    const message = { ...baseDeleteGroupRequest } as DeleteGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteGroupRequest>): DeleteGroupRequest {
    const message = { ...baseDeleteGroupRequest } as DeleteGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    return message;
  },
  toJSON(message: DeleteGroupRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    return obj;
  },
};

export const DeleteLeaderboardRecordRequest = {
  encode(message: DeleteLeaderboardRecordRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.leaderboard_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteLeaderboardRecordRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteLeaderboardRecordRequest } as DeleteLeaderboardRecordRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leaderboard_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteLeaderboardRecordRequest {
    const message = { ...baseDeleteLeaderboardRecordRequest } as DeleteLeaderboardRecordRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = String(object.leaderboard_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteLeaderboardRecordRequest>): DeleteLeaderboardRecordRequest {
    const message = { ...baseDeleteLeaderboardRecordRequest } as DeleteLeaderboardRecordRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = object.leaderboard_id;
    }
    return message;
  },
  toJSON(message: DeleteLeaderboardRecordRequest): unknown {
    const obj: any = {};
    obj.leaderboard_id = message.leaderboard_id || "";
    return obj;
  },
};

export const DeleteNotificationsRequest = {
  encode(message: DeleteNotificationsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteNotificationsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteNotificationsRequest } as DeleteNotificationsRequest;
    message.ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteNotificationsRequest {
    const message = { ...baseDeleteNotificationsRequest } as DeleteNotificationsRequest;
    message.ids = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteNotificationsRequest>): DeleteNotificationsRequest {
    const message = { ...baseDeleteNotificationsRequest } as DeleteNotificationsRequest;
    message.ids = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: DeleteNotificationsRequest): unknown {
    const obj: any = {};
    if (message.ids) {
      obj.ids = message.ids.map(e => e || "");
    } else {
      obj.ids = [];
    }
    return obj;
  },
};

export const DeleteStorageObjectId = {
  encode(message: DeleteStorageObjectId, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.collection);
    writer.uint32(18).string(message.key);
    writer.uint32(26).string(message.version);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteStorageObjectId {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteStorageObjectId } as DeleteStorageObjectId;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.version = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteStorageObjectId {
    const message = { ...baseDeleteStorageObjectId } as DeleteStorageObjectId;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = String(object.version);
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteStorageObjectId>): DeleteStorageObjectId {
    const message = { ...baseDeleteStorageObjectId } as DeleteStorageObjectId;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = object.version;
    }
    return message;
  },
  toJSON(message: DeleteStorageObjectId): unknown {
    const obj: any = {};
    obj.collection = message.collection || "";
    obj.key = message.key || "";
    obj.version = message.version || "";
    return obj;
  },
};

export const DeleteStorageObjectsRequest = {
  encode(message: DeleteStorageObjectsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.object_ids) {
      DeleteStorageObjectId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): DeleteStorageObjectsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseDeleteStorageObjectsRequest } as DeleteStorageObjectsRequest;
    message.object_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.object_ids.push(DeleteStorageObjectId.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): DeleteStorageObjectsRequest {
    const message = { ...baseDeleteStorageObjectsRequest } as DeleteStorageObjectsRequest;
    message.object_ids = [];
    if (object.object_ids !== undefined && object.object_ids !== null) {
      for (const e of object.object_ids) {
        message.object_ids.push(DeleteStorageObjectId.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<DeleteStorageObjectsRequest>): DeleteStorageObjectsRequest {
    const message = { ...baseDeleteStorageObjectsRequest } as DeleteStorageObjectsRequest;
    message.object_ids = [];
    if (object.object_ids !== undefined && object.object_ids !== null) {
      for (const e of object.object_ids) {
        message.object_ids.push(DeleteStorageObjectId.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: DeleteStorageObjectsRequest): unknown {
    const obj: any = {};
    if (message.object_ids) {
      obj.object_ids = message.object_ids.map(e => e ? DeleteStorageObjectId.toJSON(e) : undefined);
    } else {
      obj.object_ids = [];
    }
    return obj;
  },
};

export const Event = {
  encode(message: Event, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.name);
    Object.entries(message.properties).forEach(([key, value]) => {
      Event_PropertiesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).ldelim();
    })
    if (message.timestamp !== undefined && message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(32).bool(message.external);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Event {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseEvent } as Event;
    message.properties = {};
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          const entry2 = Event_PropertiesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.properties[entry2.key] = entry2.value;
          }
          break;
        case 3:
          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 4:
          message.external = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Event {
    const message = { ...baseEvent } as Event;
    message.properties = {};
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.properties !== undefined && object.properties !== null) {
      Object.entries(object.properties).forEach(([key, value]) => {
        message.properties[key] = String(value);
      })
    }
    if (object.timestamp !== undefined && object.timestamp !== null) {
      message.timestamp = fromJsonTimestamp(object.timestamp);
    }
    if (object.external !== undefined && object.external !== null) {
      message.external = Boolean(object.external);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Event>): Event {
    const message = { ...baseEvent } as Event;
    message.properties = {};
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.properties !== undefined && object.properties !== null) {
      Object.entries(object.properties).forEach(([key, value]) => {
        if (value !== undefined) {
          message.properties[key] = String(value);
        }
      })
    }
    if (object.timestamp !== undefined && object.timestamp !== null) {
      message.timestamp = object.timestamp;
    }
    if (object.external !== undefined && object.external !== null) {
      message.external = object.external;
    }
    return message;
  },
  toJSON(message: Event): unknown {
    const obj: any = {};
    obj.name = message.name || "";
    obj.properties = message.properties || undefined;
    obj.timestamp = message.timestamp !== undefined ? message.timestamp.toISOString() : null;
    obj.external = message.external || false;
    return obj;
  },
};

export const Event_PropertiesEntry = {
  encode(message: Event_PropertiesEntry, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.key);
    writer.uint32(18).string(message.value);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Event_PropertiesEntry {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseEvent_PropertiesEntry } as Event_PropertiesEntry;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.key = reader.string();
          break;
        case 2:
          message.value = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Event_PropertiesEntry {
    const message = { ...baseEvent_PropertiesEntry } as Event_PropertiesEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Event_PropertiesEntry>): Event_PropertiesEntry {
    const message = { ...baseEvent_PropertiesEntry } as Event_PropertiesEntry;
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    return message;
  },
  toJSON(message: Event_PropertiesEntry): unknown {
    const obj: any = {};
    obj.key = message.key || "";
    obj.value = message.value || "";
    return obj;
  },
};

export const Friend = {
  encode(message: Friend, writer: Writer = Writer.create()): Writer {
    if (message.user !== undefined && message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Friend {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseFriend } as Friend;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = User.decode(reader, reader.uint32());
          break;
        case 2:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Friend {
    const message = { ...baseFriend } as Friend;
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromJSON(object.user);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Friend>): Friend {
    const message = { ...baseFriend } as Friend;
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromPartial(object.user);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    return message;
  },
  toJSON(message: Friend): unknown {
    const obj: any = {};
    obj.user = message.user ? User.toJSON(message.user) : undefined;
    obj.state = message.state || undefined;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    return obj;
  },
};

export const FriendList = {
  encode(message: FriendList, writer: Writer = Writer.create()): Writer {
    for (const v of message.friends) {
      Friend.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): FriendList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseFriendList } as FriendList;
    message.friends = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.friends.push(Friend.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): FriendList {
    const message = { ...baseFriendList } as FriendList;
    message.friends = [];
    if (object.friends !== undefined && object.friends !== null) {
      for (const e of object.friends) {
        message.friends.push(Friend.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<FriendList>): FriendList {
    const message = { ...baseFriendList } as FriendList;
    message.friends = [];
    if (object.friends !== undefined && object.friends !== null) {
      for (const e of object.friends) {
        message.friends.push(Friend.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: FriendList): unknown {
    const obj: any = {};
    if (message.friends) {
      obj.friends = message.friends.map(e => e ? Friend.toJSON(e) : undefined);
    } else {
      obj.friends = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const GetUsersRequest = {
  encode(message: GetUsersRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.ids) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.usernames) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.facebook_ids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): GetUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGetUsersRequest } as GetUsersRequest;
    message.ids = [];
    message.usernames = [];
    message.facebook_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.ids.push(reader.string());
          break;
        case 2:
          message.usernames.push(reader.string());
          break;
        case 3:
          message.facebook_ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): GetUsersRequest {
    const message = { ...baseGetUsersRequest } as GetUsersRequest;
    message.ids = [];
    message.usernames = [];
    message.facebook_ids = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(String(e));
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(String(e));
      }
    }
    if (object.facebook_ids !== undefined && object.facebook_ids !== null) {
      for (const e of object.facebook_ids) {
        message.facebook_ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<GetUsersRequest>): GetUsersRequest {
    const message = { ...baseGetUsersRequest } as GetUsersRequest;
    message.ids = [];
    message.usernames = [];
    message.facebook_ids = [];
    if (object.ids !== undefined && object.ids !== null) {
      for (const e of object.ids) {
        message.ids.push(e);
      }
    }
    if (object.usernames !== undefined && object.usernames !== null) {
      for (const e of object.usernames) {
        message.usernames.push(e);
      }
    }
    if (object.facebook_ids !== undefined && object.facebook_ids !== null) {
      for (const e of object.facebook_ids) {
        message.facebook_ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: GetUsersRequest): unknown {
    const obj: any = {};
    if (message.ids) {
      obj.ids = message.ids.map(e => e || "");
    } else {
      obj.ids = [];
    }
    if (message.usernames) {
      obj.usernames = message.usernames.map(e => e || "");
    } else {
      obj.usernames = [];
    }
    if (message.facebook_ids) {
      obj.facebook_ids = message.facebook_ids.map(e => e || "");
    } else {
      obj.facebook_ids = [];
    }
    return obj;
  },
};

export const Group = {
  encode(message: Group, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    writer.uint32(18).string(message.creator_id);
    writer.uint32(26).string(message.name);
    writer.uint32(34).string(message.description);
    writer.uint32(42).string(message.lang_tag);
    writer.uint32(50).string(message.metadata);
    writer.uint32(58).string(message.avatar_url);
    if (message.open !== undefined && message.open !== undefined) {
      BoolValue.encode({ value: message.open! }, writer.uint32(66).fork()).ldelim();
    }
    writer.uint32(72).int32(message.edge_count);
    writer.uint32(80).int32(message.max_count);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(90).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(98).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Group {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGroup } as Group;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.creator_id = reader.string();
          break;
        case 3:
          message.name = reader.string();
          break;
        case 4:
          message.description = reader.string();
          break;
        case 5:
          message.lang_tag = reader.string();
          break;
        case 6:
          message.metadata = reader.string();
          break;
        case 7:
          message.avatar_url = reader.string();
          break;
        case 8:
          message.open = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 9:
          message.edge_count = reader.int32();
          break;
        case 10:
          message.max_count = reader.int32();
          break;
        case 11:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 12:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Group {
    const message = { ...baseGroup } as Group;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.creator_id !== undefined && object.creator_id !== null) {
      message.creator_id = String(object.creator_id);
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = String(object.description);
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = String(object.lang_tag);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = String(object.avatar_url);
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = Boolean(object.open);
    }
    if (object.edge_count !== undefined && object.edge_count !== null) {
      message.edge_count = Number(object.edge_count);
    }
    if (object.max_count !== undefined && object.max_count !== null) {
      message.max_count = Number(object.max_count);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Group>): Group {
    const message = { ...baseGroup } as Group;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.creator_id !== undefined && object.creator_id !== null) {
      message.creator_id = object.creator_id;
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = object.description;
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = object.lang_tag;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = object.avatar_url;
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = object.open;
    }
    if (object.edge_count !== undefined && object.edge_count !== null) {
      message.edge_count = object.edge_count;
    }
    if (object.max_count !== undefined && object.max_count !== null) {
      message.max_count = object.max_count;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    return message;
  },
  toJSON(message: Group): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.creator_id = message.creator_id || "";
    obj.name = message.name || "";
    obj.description = message.description || "";
    obj.lang_tag = message.lang_tag || "";
    obj.metadata = message.metadata || "";
    obj.avatar_url = message.avatar_url || "";
    obj.open = message.open || undefined;
    obj.edge_count = message.edge_count || 0;
    obj.max_count = message.max_count || 0;
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    return obj;
  },
};

export const GroupList = {
  encode(message: GroupList, writer: Writer = Writer.create()): Writer {
    for (const v of message.groups) {
      Group.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): GroupList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGroupList } as GroupList;
    message.groups = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.groups.push(Group.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): GroupList {
    const message = { ...baseGroupList } as GroupList;
    message.groups = [];
    if (object.groups !== undefined && object.groups !== null) {
      for (const e of object.groups) {
        message.groups.push(Group.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<GroupList>): GroupList {
    const message = { ...baseGroupList } as GroupList;
    message.groups = [];
    if (object.groups !== undefined && object.groups !== null) {
      for (const e of object.groups) {
        message.groups.push(Group.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: GroupList): unknown {
    const obj: any = {};
    if (message.groups) {
      obj.groups = message.groups.map(e => e ? Group.toJSON(e) : undefined);
    } else {
      obj.groups = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const GroupUserList = {
  encode(message: GroupUserList, writer: Writer = Writer.create()): Writer {
    for (const v of message.group_users) {
      GroupUserList_GroupUser.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): GroupUserList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGroupUserList } as GroupUserList;
    message.group_users = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_users.push(GroupUserList_GroupUser.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): GroupUserList {
    const message = { ...baseGroupUserList } as GroupUserList;
    message.group_users = [];
    if (object.group_users !== undefined && object.group_users !== null) {
      for (const e of object.group_users) {
        message.group_users.push(GroupUserList_GroupUser.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<GroupUserList>): GroupUserList {
    const message = { ...baseGroupUserList } as GroupUserList;
    message.group_users = [];
    if (object.group_users !== undefined && object.group_users !== null) {
      for (const e of object.group_users) {
        message.group_users.push(GroupUserList_GroupUser.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: GroupUserList): unknown {
    const obj: any = {};
    if (message.group_users) {
      obj.group_users = message.group_users.map(e => e ? GroupUserList_GroupUser.toJSON(e) : undefined);
    } else {
      obj.group_users = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const GroupUserList_GroupUser = {
  encode(message: GroupUserList_GroupUser, writer: Writer = Writer.create()): Writer {
    if (message.user !== undefined && message.user !== undefined) {
      User.encode(message.user, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): GroupUserList_GroupUser {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseGroupUserList_GroupUser } as GroupUserList_GroupUser;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user = User.decode(reader, reader.uint32());
          break;
        case 2:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): GroupUserList_GroupUser {
    const message = { ...baseGroupUserList_GroupUser } as GroupUserList_GroupUser;
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromJSON(object.user);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    return message;
  },
  fromPartial(object: DeepPartial<GroupUserList_GroupUser>): GroupUserList_GroupUser {
    const message = { ...baseGroupUserList_GroupUser } as GroupUserList_GroupUser;
    if (object.user !== undefined && object.user !== null) {
      message.user = User.fromPartial(object.user);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    return message;
  },
  toJSON(message: GroupUserList_GroupUser): unknown {
    const obj: any = {};
    obj.user = message.user ? User.toJSON(message.user) : undefined;
    obj.state = message.state || undefined;
    return obj;
  },
};

export const ImportFacebookFriendsRequest = {
  encode(message: ImportFacebookFriendsRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.reset !== undefined && message.reset !== undefined) {
      BoolValue.encode({ value: message.reset! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ImportFacebookFriendsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseImportFacebookFriendsRequest } as ImportFacebookFriendsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountFacebook.decode(reader, reader.uint32());
          break;
        case 2:
          message.reset = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ImportFacebookFriendsRequest {
    const message = { ...baseImportFacebookFriendsRequest } as ImportFacebookFriendsRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromJSON(object.account);
    }
    if (object.reset !== undefined && object.reset !== null) {
      message.reset = Boolean(object.reset);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ImportFacebookFriendsRequest>): ImportFacebookFriendsRequest {
    const message = { ...baseImportFacebookFriendsRequest } as ImportFacebookFriendsRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromPartial(object.account);
    }
    if (object.reset !== undefined && object.reset !== null) {
      message.reset = object.reset;
    }
    return message;
  },
  toJSON(message: ImportFacebookFriendsRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined;
    obj.reset = message.reset || undefined;
    return obj;
  },
};

export const JoinGroupRequest = {
  encode(message: JoinGroupRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): JoinGroupRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseJoinGroupRequest } as JoinGroupRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): JoinGroupRequest {
    const message = { ...baseJoinGroupRequest } as JoinGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<JoinGroupRequest>): JoinGroupRequest {
    const message = { ...baseJoinGroupRequest } as JoinGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    return message;
  },
  toJSON(message: JoinGroupRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    return obj;
  },
};

export const JoinTournamentRequest = {
  encode(message: JoinTournamentRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.tournament_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): JoinTournamentRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseJoinTournamentRequest } as JoinTournamentRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tournament_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): JoinTournamentRequest {
    const message = { ...baseJoinTournamentRequest } as JoinTournamentRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = String(object.tournament_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<JoinTournamentRequest>): JoinTournamentRequest {
    const message = { ...baseJoinTournamentRequest } as JoinTournamentRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = object.tournament_id;
    }
    return message;
  },
  toJSON(message: JoinTournamentRequest): unknown {
    const obj: any = {};
    obj.tournament_id = message.tournament_id || "";
    return obj;
  },
};

export const KickGroupUsersRequest = {
  encode(message: KickGroupUsersRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): KickGroupUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseKickGroupUsersRequest } as KickGroupUsersRequest;
    message.user_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.user_ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): KickGroupUsersRequest {
    const message = { ...baseKickGroupUsersRequest } as KickGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<KickGroupUsersRequest>): KickGroupUsersRequest {
    const message = { ...baseKickGroupUsersRequest } as KickGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: KickGroupUsersRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    if (message.user_ids) {
      obj.user_ids = message.user_ids.map(e => e || "");
    } else {
      obj.user_ids = [];
    }
    return obj;
  },
};

export const LeaderboardRecord = {
  encode(message: LeaderboardRecord, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.leaderboard_id);
    writer.uint32(18).string(message.owner_id);
    if (message.username !== undefined && message.username !== undefined) {
      StringValue.encode({ value: message.username! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(32).int64(message.score);
    writer.uint32(40).int64(message.subscore);
    writer.uint32(48).int32(message.num_score);
    writer.uint32(58).string(message.metadata);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(74).fork()).ldelim();
    }
    if (message.expiry_time !== undefined && message.expiry_time !== undefined) {
      Timestamp.encode(toTimestamp(message.expiry_time), writer.uint32(82).fork()).ldelim();
    }
    writer.uint32(88).int64(message.rank);
    writer.uint32(96).uint32(message.max_num_score);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): LeaderboardRecord {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLeaderboardRecord } as LeaderboardRecord;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leaderboard_id = reader.string();
          break;
        case 2:
          message.owner_id = reader.string();
          break;
        case 3:
          message.username = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.score = longToNumber(reader.int64() as Long);
          break;
        case 5:
          message.subscore = longToNumber(reader.int64() as Long);
          break;
        case 6:
          message.num_score = reader.int32();
          break;
        case 7:
          message.metadata = reader.string();
          break;
        case 8:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 9:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 10:
          message.expiry_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 11:
          message.rank = longToNumber(reader.int64() as Long);
          break;
        case 12:
          message.max_num_score = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): LeaderboardRecord {
    const message = { ...baseLeaderboardRecord } as LeaderboardRecord;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = String(object.leaderboard_id);
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = String(object.owner_id);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    if (object.score !== undefined && object.score !== null) {
      message.score = Number(object.score);
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = Number(object.subscore);
    }
    if (object.num_score !== undefined && object.num_score !== null) {
      message.num_score = Number(object.num_score);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    if (object.expiry_time !== undefined && object.expiry_time !== null) {
      message.expiry_time = fromJsonTimestamp(object.expiry_time);
    }
    if (object.rank !== undefined && object.rank !== null) {
      message.rank = Number(object.rank);
    }
    if (object.max_num_score !== undefined && object.max_num_score !== null) {
      message.max_num_score = Number(object.max_num_score);
    }
    return message;
  },
  fromPartial(object: DeepPartial<LeaderboardRecord>): LeaderboardRecord {
    const message = { ...baseLeaderboardRecord } as LeaderboardRecord;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = object.leaderboard_id;
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = object.owner_id;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    if (object.score !== undefined && object.score !== null) {
      message.score = object.score;
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = object.subscore;
    }
    if (object.num_score !== undefined && object.num_score !== null) {
      message.num_score = object.num_score;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    if (object.expiry_time !== undefined && object.expiry_time !== null) {
      message.expiry_time = object.expiry_time;
    }
    if (object.rank !== undefined && object.rank !== null) {
      message.rank = object.rank;
    }
    if (object.max_num_score !== undefined && object.max_num_score !== null) {
      message.max_num_score = object.max_num_score;
    }
    return message;
  },
  toJSON(message: LeaderboardRecord): unknown {
    const obj: any = {};
    obj.leaderboard_id = message.leaderboard_id || "";
    obj.owner_id = message.owner_id || "";
    obj.username = message.username || undefined;
    obj.score = message.score || 0;
    obj.subscore = message.subscore || 0;
    obj.num_score = message.num_score || 0;
    obj.metadata = message.metadata || "";
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    obj.expiry_time = message.expiry_time !== undefined ? message.expiry_time.toISOString() : null;
    obj.rank = message.rank || 0;
    obj.max_num_score = message.max_num_score || 0;
    return obj;
  },
};

export const LeaderboardRecordList = {
  encode(message: LeaderboardRecordList, writer: Writer = Writer.create()): Writer {
    for (const v of message.records) {
      LeaderboardRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.owner_records) {
      LeaderboardRecord.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.next_cursor);
    writer.uint32(34).string(message.prev_cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): LeaderboardRecordList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLeaderboardRecordList } as LeaderboardRecordList;
    message.records = [];
    message.owner_records = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.records.push(LeaderboardRecord.decode(reader, reader.uint32()));
          break;
        case 2:
          message.owner_records.push(LeaderboardRecord.decode(reader, reader.uint32()));
          break;
        case 3:
          message.next_cursor = reader.string();
          break;
        case 4:
          message.prev_cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): LeaderboardRecordList {
    const message = { ...baseLeaderboardRecordList } as LeaderboardRecordList;
    message.records = [];
    message.owner_records = [];
    if (object.records !== undefined && object.records !== null) {
      for (const e of object.records) {
        message.records.push(LeaderboardRecord.fromJSON(e));
      }
    }
    if (object.owner_records !== undefined && object.owner_records !== null) {
      for (const e of object.owner_records) {
        message.owner_records.push(LeaderboardRecord.fromJSON(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = String(object.next_cursor);
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = String(object.prev_cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<LeaderboardRecordList>): LeaderboardRecordList {
    const message = { ...baseLeaderboardRecordList } as LeaderboardRecordList;
    message.records = [];
    message.owner_records = [];
    if (object.records !== undefined && object.records !== null) {
      for (const e of object.records) {
        message.records.push(LeaderboardRecord.fromPartial(e));
      }
    }
    if (object.owner_records !== undefined && object.owner_records !== null) {
      for (const e of object.owner_records) {
        message.owner_records.push(LeaderboardRecord.fromPartial(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = object.next_cursor;
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = object.prev_cursor;
    }
    return message;
  },
  toJSON(message: LeaderboardRecordList): unknown {
    const obj: any = {};
    if (message.records) {
      obj.records = message.records.map(e => e ? LeaderboardRecord.toJSON(e) : undefined);
    } else {
      obj.records = [];
    }
    if (message.owner_records) {
      obj.owner_records = message.owner_records.map(e => e ? LeaderboardRecord.toJSON(e) : undefined);
    } else {
      obj.owner_records = [];
    }
    obj.next_cursor = message.next_cursor || "";
    obj.prev_cursor = message.prev_cursor || "";
    return obj;
  },
};

export const LeaveGroupRequest = {
  encode(message: LeaveGroupRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): LeaveGroupRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLeaveGroupRequest } as LeaveGroupRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): LeaveGroupRequest {
    const message = { ...baseLeaveGroupRequest } as LeaveGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<LeaveGroupRequest>): LeaveGroupRequest {
    const message = { ...baseLeaveGroupRequest } as LeaveGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    return message;
  },
  toJSON(message: LeaveGroupRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    return obj;
  },
};

export const LinkFacebookRequest = {
  encode(message: LinkFacebookRequest, writer: Writer = Writer.create()): Writer {
    if (message.account !== undefined && message.account !== undefined) {
      AccountFacebook.encode(message.account, writer.uint32(10).fork()).ldelim();
    }
    if (message.sync !== undefined && message.sync !== undefined) {
      BoolValue.encode({ value: message.sync! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): LinkFacebookRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseLinkFacebookRequest } as LinkFacebookRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.account = AccountFacebook.decode(reader, reader.uint32());
          break;
        case 4:
          message.sync = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): LinkFacebookRequest {
    const message = { ...baseLinkFacebookRequest } as LinkFacebookRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromJSON(object.account);
    }
    if (object.sync !== undefined && object.sync !== null) {
      message.sync = Boolean(object.sync);
    }
    return message;
  },
  fromPartial(object: DeepPartial<LinkFacebookRequest>): LinkFacebookRequest {
    const message = { ...baseLinkFacebookRequest } as LinkFacebookRequest;
    if (object.account !== undefined && object.account !== null) {
      message.account = AccountFacebook.fromPartial(object.account);
    }
    if (object.sync !== undefined && object.sync !== null) {
      message.sync = object.sync;
    }
    return message;
  },
  toJSON(message: LinkFacebookRequest): unknown {
    const obj: any = {};
    obj.account = message.account ? AccountFacebook.toJSON(message.account) : undefined;
    obj.sync = message.sync || undefined;
    return obj;
  },
};

export const ListChannelMessagesRequest = {
  encode(message: ListChannelMessagesRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.channel_id);
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.forward !== undefined && message.forward !== undefined) {
      BoolValue.encode({ value: message.forward! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListChannelMessagesRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListChannelMessagesRequest } as ListChannelMessagesRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.channel_id = reader.string();
          break;
        case 2:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.forward = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListChannelMessagesRequest {
    const message = { ...baseListChannelMessagesRequest } as ListChannelMessagesRequest;
    if (object.channel_id !== undefined && object.channel_id !== null) {
      message.channel_id = String(object.channel_id);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.forward !== undefined && object.forward !== null) {
      message.forward = Boolean(object.forward);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListChannelMessagesRequest>): ListChannelMessagesRequest {
    const message = { ...baseListChannelMessagesRequest } as ListChannelMessagesRequest;
    if (object.channel_id !== undefined && object.channel_id !== null) {
      message.channel_id = object.channel_id;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.forward !== undefined && object.forward !== null) {
      message.forward = object.forward;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListChannelMessagesRequest): unknown {
    const obj: any = {};
    obj.channel_id = message.channel_id || "";
    obj.limit = message.limit || undefined;
    obj.forward = message.forward || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const ListFriendsRequest = {
  encode(message: ListFriendsRequest, writer: Writer = Writer.create()): Writer {
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListFriendsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListFriendsRequest } as ListFriendsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListFriendsRequest {
    const message = { ...baseListFriendsRequest } as ListFriendsRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListFriendsRequest>): ListFriendsRequest {
    const message = { ...baseListFriendsRequest } as ListFriendsRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListFriendsRequest): unknown {
    const obj: any = {};
    obj.limit = message.limit || undefined;
    obj.state = message.state || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const ListGroupsRequest = {
  encode(message: ListGroupsRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.name);
    writer.uint32(18).string(message.cursor);
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListGroupsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListGroupsRequest } as ListGroupsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.name = reader.string();
          break;
        case 2:
          message.cursor = reader.string();
          break;
        case 3:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListGroupsRequest {
    const message = { ...baseListGroupsRequest } as ListGroupsRequest;
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListGroupsRequest>): ListGroupsRequest {
    const message = { ...baseListGroupsRequest } as ListGroupsRequest;
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    return message;
  },
  toJSON(message: ListGroupsRequest): unknown {
    const obj: any = {};
    obj.name = message.name || "";
    obj.cursor = message.cursor || "";
    obj.limit = message.limit || undefined;
    return obj;
  },
};

export const ListGroupUsersRequest = {
  encode(message: ListGroupUsersRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListGroupUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListGroupUsersRequest } as ListGroupUsersRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListGroupUsersRequest {
    const message = { ...baseListGroupUsersRequest } as ListGroupUsersRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListGroupUsersRequest>): ListGroupUsersRequest {
    const message = { ...baseListGroupUsersRequest } as ListGroupUsersRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListGroupUsersRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    obj.limit = message.limit || undefined;
    obj.state = message.state || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const ListLeaderboardRecordsAroundOwnerRequest = {
  encode(message: ListLeaderboardRecordsAroundOwnerRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.leaderboard_id);
    if (message.limit !== undefined && message.limit !== undefined) {
      UInt32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.owner_id);
    if (message.expiry !== undefined && message.expiry !== undefined) {
      Int64Value.encode({ value: message.expiry! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListLeaderboardRecordsAroundOwnerRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListLeaderboardRecordsAroundOwnerRequest } as ListLeaderboardRecordsAroundOwnerRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leaderboard_id = reader.string();
          break;
        case 2:
          message.limit = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.owner_id = reader.string();
          break;
        case 4:
          message.expiry = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListLeaderboardRecordsAroundOwnerRequest {
    const message = { ...baseListLeaderboardRecordsAroundOwnerRequest } as ListLeaderboardRecordsAroundOwnerRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = String(object.leaderboard_id);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = String(object.owner_id);
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = Number(object.expiry);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListLeaderboardRecordsAroundOwnerRequest>): ListLeaderboardRecordsAroundOwnerRequest {
    const message = { ...baseListLeaderboardRecordsAroundOwnerRequest } as ListLeaderboardRecordsAroundOwnerRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = object.leaderboard_id;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = object.owner_id;
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = object.expiry;
    }
    return message;
  },
  toJSON(message: ListLeaderboardRecordsAroundOwnerRequest): unknown {
    const obj: any = {};
    obj.leaderboard_id = message.leaderboard_id || "";
    obj.limit = message.limit || undefined;
    obj.owner_id = message.owner_id || "";
    obj.expiry = message.expiry || undefined;
    return obj;
  },
};

export const ListLeaderboardRecordsRequest = {
  encode(message: ListLeaderboardRecordsRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.leaderboard_id);
    for (const v of message.owner_ids) {
      writer.uint32(18).string(v!);
    }
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    if (message.expiry !== undefined && message.expiry !== undefined) {
      Int64Value.encode({ value: message.expiry! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListLeaderboardRecordsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListLeaderboardRecordsRequest } as ListLeaderboardRecordsRequest;
    message.owner_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leaderboard_id = reader.string();
          break;
        case 2:
          message.owner_ids.push(reader.string());
          break;
        case 3:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        case 5:
          message.expiry = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListLeaderboardRecordsRequest {
    const message = { ...baseListLeaderboardRecordsRequest } as ListLeaderboardRecordsRequest;
    message.owner_ids = [];
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = String(object.leaderboard_id);
    }
    if (object.owner_ids !== undefined && object.owner_ids !== null) {
      for (const e of object.owner_ids) {
        message.owner_ids.push(String(e));
      }
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = Number(object.expiry);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListLeaderboardRecordsRequest>): ListLeaderboardRecordsRequest {
    const message = { ...baseListLeaderboardRecordsRequest } as ListLeaderboardRecordsRequest;
    message.owner_ids = [];
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = object.leaderboard_id;
    }
    if (object.owner_ids !== undefined && object.owner_ids !== null) {
      for (const e of object.owner_ids) {
        message.owner_ids.push(e);
      }
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = object.expiry;
    }
    return message;
  },
  toJSON(message: ListLeaderboardRecordsRequest): unknown {
    const obj: any = {};
    obj.leaderboard_id = message.leaderboard_id || "";
    if (message.owner_ids) {
      obj.owner_ids = message.owner_ids.map(e => e || "");
    } else {
      obj.owner_ids = [];
    }
    obj.limit = message.limit || undefined;
    obj.cursor = message.cursor || "";
    obj.expiry = message.expiry || undefined;
    return obj;
  },
};

export const ListMatchesRequest = {
  encode(message: ListMatchesRequest, writer: Writer = Writer.create()): Writer {
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.authoritative !== undefined && message.authoritative !== undefined) {
      BoolValue.encode({ value: message.authoritative! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.label !== undefined && message.label !== undefined) {
      StringValue.encode({ value: message.label! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.min_size !== undefined && message.min_size !== undefined) {
      Int32Value.encode({ value: message.min_size! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.max_size !== undefined && message.max_size !== undefined) {
      Int32Value.encode({ value: message.max_size! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.query !== undefined && message.query !== undefined) {
      StringValue.encode({ value: message.query! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListMatchesRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListMatchesRequest } as ListMatchesRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.authoritative = BoolValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.label = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.min_size = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.max_size = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.query = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListMatchesRequest {
    const message = { ...baseListMatchesRequest } as ListMatchesRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.authoritative !== undefined && object.authoritative !== null) {
      message.authoritative = Boolean(object.authoritative);
    }
    if (object.label !== undefined && object.label !== null) {
      message.label = String(object.label);
    }
    if (object.min_size !== undefined && object.min_size !== null) {
      message.min_size = Number(object.min_size);
    }
    if (object.max_size !== undefined && object.max_size !== null) {
      message.max_size = Number(object.max_size);
    }
    if (object.query !== undefined && object.query !== null) {
      message.query = String(object.query);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListMatchesRequest>): ListMatchesRequest {
    const message = { ...baseListMatchesRequest } as ListMatchesRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.authoritative !== undefined && object.authoritative !== null) {
      message.authoritative = object.authoritative;
    }
    if (object.label !== undefined && object.label !== null) {
      message.label = object.label;
    }
    if (object.min_size !== undefined && object.min_size !== null) {
      message.min_size = object.min_size;
    }
    if (object.max_size !== undefined && object.max_size !== null) {
      message.max_size = object.max_size;
    }
    if (object.query !== undefined && object.query !== null) {
      message.query = object.query;
    }
    return message;
  },
  toJSON(message: ListMatchesRequest): unknown {
    const obj: any = {};
    obj.limit = message.limit || undefined;
    obj.authoritative = message.authoritative || undefined;
    obj.label = message.label || undefined;
    obj.min_size = message.min_size || undefined;
    obj.max_size = message.max_size || undefined;
    obj.query = message.query || undefined;
    return obj;
  },
};

export const ListNotificationsRequest = {
  encode(message: ListNotificationsRequest, writer: Writer = Writer.create()): Writer {
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cacheable_cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListNotificationsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListNotificationsRequest } as ListNotificationsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.cacheable_cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListNotificationsRequest {
    const message = { ...baseListNotificationsRequest } as ListNotificationsRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.cacheable_cursor !== undefined && object.cacheable_cursor !== null) {
      message.cacheable_cursor = String(object.cacheable_cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListNotificationsRequest>): ListNotificationsRequest {
    const message = { ...baseListNotificationsRequest } as ListNotificationsRequest;
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.cacheable_cursor !== undefined && object.cacheable_cursor !== null) {
      message.cacheable_cursor = object.cacheable_cursor;
    }
    return message;
  },
  toJSON(message: ListNotificationsRequest): unknown {
    const obj: any = {};
    obj.limit = message.limit || undefined;
    obj.cacheable_cursor = message.cacheable_cursor || "";
    return obj;
  },
};

export const ListStorageObjectsRequest = {
  encode(message: ListStorageObjectsRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.user_id);
    writer.uint32(18).string(message.collection);
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListStorageObjectsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListStorageObjectsRequest } as ListStorageObjectsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user_id = reader.string();
          break;
        case 2:
          message.collection = reader.string();
          break;
        case 3:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListStorageObjectsRequest {
    const message = { ...baseListStorageObjectsRequest } as ListStorageObjectsRequest;
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = String(object.user_id);
    }
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListStorageObjectsRequest>): ListStorageObjectsRequest {
    const message = { ...baseListStorageObjectsRequest } as ListStorageObjectsRequest;
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = object.user_id;
    }
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListStorageObjectsRequest): unknown {
    const obj: any = {};
    obj.user_id = message.user_id || "";
    obj.collection = message.collection || "";
    obj.limit = message.limit || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const ListTournamentRecordsAroundOwnerRequest = {
  encode(message: ListTournamentRecordsAroundOwnerRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.tournament_id);
    if (message.limit !== undefined && message.limit !== undefined) {
      UInt32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.owner_id);
    if (message.expiry !== undefined && message.expiry !== undefined) {
      Int64Value.encode({ value: message.expiry! }, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListTournamentRecordsAroundOwnerRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListTournamentRecordsAroundOwnerRequest } as ListTournamentRecordsAroundOwnerRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tournament_id = reader.string();
          break;
        case 2:
          message.limit = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.owner_id = reader.string();
          break;
        case 4:
          message.expiry = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListTournamentRecordsAroundOwnerRequest {
    const message = { ...baseListTournamentRecordsAroundOwnerRequest } as ListTournamentRecordsAroundOwnerRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = String(object.tournament_id);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = String(object.owner_id);
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = Number(object.expiry);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListTournamentRecordsAroundOwnerRequest>): ListTournamentRecordsAroundOwnerRequest {
    const message = { ...baseListTournamentRecordsAroundOwnerRequest } as ListTournamentRecordsAroundOwnerRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = object.tournament_id;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.owner_id !== undefined && object.owner_id !== null) {
      message.owner_id = object.owner_id;
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = object.expiry;
    }
    return message;
  },
  toJSON(message: ListTournamentRecordsAroundOwnerRequest): unknown {
    const obj: any = {};
    obj.tournament_id = message.tournament_id || "";
    obj.limit = message.limit || undefined;
    obj.owner_id = message.owner_id || "";
    obj.expiry = message.expiry || undefined;
    return obj;
  },
};

export const ListTournamentRecordsRequest = {
  encode(message: ListTournamentRecordsRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.tournament_id);
    for (const v of message.owner_ids) {
      writer.uint32(18).string(v!);
    }
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    if (message.expiry !== undefined && message.expiry !== undefined) {
      Int64Value.encode({ value: message.expiry! }, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListTournamentRecordsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListTournamentRecordsRequest } as ListTournamentRecordsRequest;
    message.owner_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tournament_id = reader.string();
          break;
        case 2:
          message.owner_ids.push(reader.string());
          break;
        case 3:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        case 5:
          message.expiry = Int64Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListTournamentRecordsRequest {
    const message = { ...baseListTournamentRecordsRequest } as ListTournamentRecordsRequest;
    message.owner_ids = [];
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = String(object.tournament_id);
    }
    if (object.owner_ids !== undefined && object.owner_ids !== null) {
      for (const e of object.owner_ids) {
        message.owner_ids.push(String(e));
      }
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = Number(object.expiry);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListTournamentRecordsRequest>): ListTournamentRecordsRequest {
    const message = { ...baseListTournamentRecordsRequest } as ListTournamentRecordsRequest;
    message.owner_ids = [];
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = object.tournament_id;
    }
    if (object.owner_ids !== undefined && object.owner_ids !== null) {
      for (const e of object.owner_ids) {
        message.owner_ids.push(e);
      }
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    if (object.expiry !== undefined && object.expiry !== null) {
      message.expiry = object.expiry;
    }
    return message;
  },
  toJSON(message: ListTournamentRecordsRequest): unknown {
    const obj: any = {};
    obj.tournament_id = message.tournament_id || "";
    if (message.owner_ids) {
      obj.owner_ids = message.owner_ids.map(e => e || "");
    } else {
      obj.owner_ids = [];
    }
    obj.limit = message.limit || undefined;
    obj.cursor = message.cursor || "";
    obj.expiry = message.expiry || undefined;
    return obj;
  },
};

export const ListTournamentsRequest = {
  encode(message: ListTournamentsRequest, writer: Writer = Writer.create()): Writer {
    if (message.category_start !== undefined && message.category_start !== undefined) {
      UInt32Value.encode({ value: message.category_start! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.category_end !== undefined && message.category_end !== undefined) {
      UInt32Value.encode({ value: message.category_end! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.start_time !== undefined && message.start_time !== undefined) {
      UInt32Value.encode({ value: message.start_time! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.end_time !== undefined && message.end_time !== undefined) {
      UInt32Value.encode({ value: message.end_time! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(66).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListTournamentsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListTournamentsRequest } as ListTournamentsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.category_start = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.category_end = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.start_time = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.end_time = UInt32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 8:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListTournamentsRequest {
    const message = { ...baseListTournamentsRequest } as ListTournamentsRequest;
    if (object.category_start !== undefined && object.category_start !== null) {
      message.category_start = Number(object.category_start);
    }
    if (object.category_end !== undefined && object.category_end !== null) {
      message.category_end = Number(object.category_end);
    }
    if (object.start_time !== undefined && object.start_time !== null) {
      message.start_time = Number(object.start_time);
    }
    if (object.end_time !== undefined && object.end_time !== null) {
      message.end_time = Number(object.end_time);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListTournamentsRequest>): ListTournamentsRequest {
    const message = { ...baseListTournamentsRequest } as ListTournamentsRequest;
    if (object.category_start !== undefined && object.category_start !== null) {
      message.category_start = object.category_start;
    }
    if (object.category_end !== undefined && object.category_end !== null) {
      message.category_end = object.category_end;
    }
    if (object.start_time !== undefined && object.start_time !== null) {
      message.start_time = object.start_time;
    }
    if (object.end_time !== undefined && object.end_time !== null) {
      message.end_time = object.end_time;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListTournamentsRequest): unknown {
    const obj: any = {};
    obj.category_start = message.category_start || undefined;
    obj.category_end = message.category_end || undefined;
    obj.start_time = message.start_time || undefined;
    obj.end_time = message.end_time || undefined;
    obj.limit = message.limit || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const ListUserGroupsRequest = {
  encode(message: ListUserGroupsRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.user_id);
    if (message.limit !== undefined && message.limit !== undefined) {
      Int32Value.encode({ value: message.limit! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(34).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ListUserGroupsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseListUserGroupsRequest } as ListUserGroupsRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user_id = reader.string();
          break;
        case 2:
          message.limit = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ListUserGroupsRequest {
    const message = { ...baseListUserGroupsRequest } as ListUserGroupsRequest;
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = String(object.user_id);
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = Number(object.limit);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ListUserGroupsRequest>): ListUserGroupsRequest {
    const message = { ...baseListUserGroupsRequest } as ListUserGroupsRequest;
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = object.user_id;
    }
    if (object.limit !== undefined && object.limit !== null) {
      message.limit = object.limit;
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: ListUserGroupsRequest): unknown {
    const obj: any = {};
    obj.user_id = message.user_id || "";
    obj.limit = message.limit || undefined;
    obj.state = message.state || undefined;
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const Match = {
  encode(message: Match, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.match_id);
    writer.uint32(16).bool(message.authoritative);
    if (message.label !== undefined && message.label !== undefined) {
      StringValue.encode({ value: message.label! }, writer.uint32(26).fork()).ldelim();
    }
    writer.uint32(32).int32(message.size);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Match {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMatch } as Match;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.match_id = reader.string();
          break;
        case 2:
          message.authoritative = reader.bool();
          break;
        case 3:
          message.label = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.size = reader.int32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Match {
    const message = { ...baseMatch } as Match;
    if (object.match_id !== undefined && object.match_id !== null) {
      message.match_id = String(object.match_id);
    }
    if (object.authoritative !== undefined && object.authoritative !== null) {
      message.authoritative = Boolean(object.authoritative);
    }
    if (object.label !== undefined && object.label !== null) {
      message.label = String(object.label);
    }
    if (object.size !== undefined && object.size !== null) {
      message.size = Number(object.size);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Match>): Match {
    const message = { ...baseMatch } as Match;
    if (object.match_id !== undefined && object.match_id !== null) {
      message.match_id = object.match_id;
    }
    if (object.authoritative !== undefined && object.authoritative !== null) {
      message.authoritative = object.authoritative;
    }
    if (object.label !== undefined && object.label !== null) {
      message.label = object.label;
    }
    if (object.size !== undefined && object.size !== null) {
      message.size = object.size;
    }
    return message;
  },
  toJSON(message: Match): unknown {
    const obj: any = {};
    obj.match_id = message.match_id || "";
    obj.authoritative = message.authoritative || false;
    obj.label = message.label || undefined;
    obj.size = message.size || 0;
    return obj;
  },
};

export const MatchList = {
  encode(message: MatchList, writer: Writer = Writer.create()): Writer {
    for (const v of message.matches) {
      Match.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): MatchList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseMatchList } as MatchList;
    message.matches = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.matches.push(Match.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): MatchList {
    const message = { ...baseMatchList } as MatchList;
    message.matches = [];
    if (object.matches !== undefined && object.matches !== null) {
      for (const e of object.matches) {
        message.matches.push(Match.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<MatchList>): MatchList {
    const message = { ...baseMatchList } as MatchList;
    message.matches = [];
    if (object.matches !== undefined && object.matches !== null) {
      for (const e of object.matches) {
        message.matches.push(Match.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: MatchList): unknown {
    const obj: any = {};
    if (message.matches) {
      obj.matches = message.matches.map(e => e ? Match.toJSON(e) : undefined);
    } else {
      obj.matches = [];
    }
    return obj;
  },
};

export const Notification = {
  encode(message: Notification, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    writer.uint32(18).string(message.subject);
    writer.uint32(26).string(message.content);
    writer.uint32(32).int32(message.code);
    writer.uint32(42).string(message.sender_id);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(50).fork()).ldelim();
    }
    writer.uint32(56).bool(message.persistent);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Notification {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseNotification } as Notification;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.subject = reader.string();
          break;
        case 3:
          message.content = reader.string();
          break;
        case 4:
          message.code = reader.int32();
          break;
        case 5:
          message.sender_id = reader.string();
          break;
        case 6:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 7:
          message.persistent = reader.bool();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Notification {
    const message = { ...baseNotification } as Notification;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.subject !== undefined && object.subject !== null) {
      message.subject = String(object.subject);
    }
    if (object.content !== undefined && object.content !== null) {
      message.content = String(object.content);
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = Number(object.code);
    }
    if (object.sender_id !== undefined && object.sender_id !== null) {
      message.sender_id = String(object.sender_id);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.persistent !== undefined && object.persistent !== null) {
      message.persistent = Boolean(object.persistent);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Notification>): Notification {
    const message = { ...baseNotification } as Notification;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.subject !== undefined && object.subject !== null) {
      message.subject = object.subject;
    }
    if (object.content !== undefined && object.content !== null) {
      message.content = object.content;
    }
    if (object.code !== undefined && object.code !== null) {
      message.code = object.code;
    }
    if (object.sender_id !== undefined && object.sender_id !== null) {
      message.sender_id = object.sender_id;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.persistent !== undefined && object.persistent !== null) {
      message.persistent = object.persistent;
    }
    return message;
  },
  toJSON(message: Notification): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.subject = message.subject || "";
    obj.content = message.content || "";
    obj.code = message.code || 0;
    obj.sender_id = message.sender_id || "";
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.persistent = message.persistent || false;
    return obj;
  },
};

export const NotificationList = {
  encode(message: NotificationList, writer: Writer = Writer.create()): Writer {
    for (const v of message.notifications) {
      Notification.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cacheable_cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): NotificationList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseNotificationList } as NotificationList;
    message.notifications = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.notifications.push(Notification.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cacheable_cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): NotificationList {
    const message = { ...baseNotificationList } as NotificationList;
    message.notifications = [];
    if (object.notifications !== undefined && object.notifications !== null) {
      for (const e of object.notifications) {
        message.notifications.push(Notification.fromJSON(e));
      }
    }
    if (object.cacheable_cursor !== undefined && object.cacheable_cursor !== null) {
      message.cacheable_cursor = String(object.cacheable_cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<NotificationList>): NotificationList {
    const message = { ...baseNotificationList } as NotificationList;
    message.notifications = [];
    if (object.notifications !== undefined && object.notifications !== null) {
      for (const e of object.notifications) {
        message.notifications.push(Notification.fromPartial(e));
      }
    }
    if (object.cacheable_cursor !== undefined && object.cacheable_cursor !== null) {
      message.cacheable_cursor = object.cacheable_cursor;
    }
    return message;
  },
  toJSON(message: NotificationList): unknown {
    const obj: any = {};
    if (message.notifications) {
      obj.notifications = message.notifications.map(e => e ? Notification.toJSON(e) : undefined);
    } else {
      obj.notifications = [];
    }
    obj.cacheable_cursor = message.cacheable_cursor || "";
    return obj;
  },
};

export const PromoteGroupUsersRequest = {
  encode(message: PromoteGroupUsersRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    for (const v of message.user_ids) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): PromoteGroupUsersRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...basePromoteGroupUsersRequest } as PromoteGroupUsersRequest;
    message.user_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.user_ids.push(reader.string());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): PromoteGroupUsersRequest {
    const message = { ...basePromoteGroupUsersRequest } as PromoteGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(String(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<PromoteGroupUsersRequest>): PromoteGroupUsersRequest {
    const message = { ...basePromoteGroupUsersRequest } as PromoteGroupUsersRequest;
    message.user_ids = [];
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.user_ids !== undefined && object.user_ids !== null) {
      for (const e of object.user_ids) {
        message.user_ids.push(e);
      }
    }
    return message;
  },
  toJSON(message: PromoteGroupUsersRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    if (message.user_ids) {
      obj.user_ids = message.user_ids.map(e => e || "");
    } else {
      obj.user_ids = [];
    }
    return obj;
  },
};

export const ReadStorageObjectId = {
  encode(message: ReadStorageObjectId, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.collection);
    writer.uint32(18).string(message.key);
    writer.uint32(26).string(message.user_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ReadStorageObjectId {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseReadStorageObjectId } as ReadStorageObjectId;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.user_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ReadStorageObjectId {
    const message = { ...baseReadStorageObjectId } as ReadStorageObjectId;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = String(object.user_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<ReadStorageObjectId>): ReadStorageObjectId {
    const message = { ...baseReadStorageObjectId } as ReadStorageObjectId;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = object.user_id;
    }
    return message;
  },
  toJSON(message: ReadStorageObjectId): unknown {
    const obj: any = {};
    obj.collection = message.collection || "";
    obj.key = message.key || "";
    obj.user_id = message.user_id || "";
    return obj;
  },
};

export const ReadStorageObjectsRequest = {
  encode(message: ReadStorageObjectsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.object_ids) {
      ReadStorageObjectId.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): ReadStorageObjectsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseReadStorageObjectsRequest } as ReadStorageObjectsRequest;
    message.object_ids = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.object_ids.push(ReadStorageObjectId.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): ReadStorageObjectsRequest {
    const message = { ...baseReadStorageObjectsRequest } as ReadStorageObjectsRequest;
    message.object_ids = [];
    if (object.object_ids !== undefined && object.object_ids !== null) {
      for (const e of object.object_ids) {
        message.object_ids.push(ReadStorageObjectId.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<ReadStorageObjectsRequest>): ReadStorageObjectsRequest {
    const message = { ...baseReadStorageObjectsRequest } as ReadStorageObjectsRequest;
    message.object_ids = [];
    if (object.object_ids !== undefined && object.object_ids !== null) {
      for (const e of object.object_ids) {
        message.object_ids.push(ReadStorageObjectId.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: ReadStorageObjectsRequest): unknown {
    const obj: any = {};
    if (message.object_ids) {
      obj.object_ids = message.object_ids.map(e => e ? ReadStorageObjectId.toJSON(e) : undefined);
    } else {
      obj.object_ids = [];
    }
    return obj;
  },
};

export const Rpc = {
  encode(message: Rpc, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    writer.uint32(18).string(message.payload);
    writer.uint32(26).string(message.http_key);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Rpc {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseRpc } as Rpc;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.payload = reader.string();
          break;
        case 3:
          message.http_key = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Rpc {
    const message = { ...baseRpc } as Rpc;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.payload !== undefined && object.payload !== null) {
      message.payload = String(object.payload);
    }
    if (object.http_key !== undefined && object.http_key !== null) {
      message.http_key = String(object.http_key);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Rpc>): Rpc {
    const message = { ...baseRpc } as Rpc;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.payload !== undefined && object.payload !== null) {
      message.payload = object.payload;
    }
    if (object.http_key !== undefined && object.http_key !== null) {
      message.http_key = object.http_key;
    }
    return message;
  },
  toJSON(message: Rpc): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.payload = message.payload || "";
    obj.http_key = message.http_key || "";
    return obj;
  },
};

export const Session = {
  encode(message: Session, writer: Writer = Writer.create()): Writer {
    writer.uint32(8).bool(message.created);
    writer.uint32(18).string(message.token);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Session {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseSession } as Session;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.created = reader.bool();
          break;
        case 2:
          message.token = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Session {
    const message = { ...baseSession } as Session;
    if (object.created !== undefined && object.created !== null) {
      message.created = Boolean(object.created);
    }
    if (object.token !== undefined && object.token !== null) {
      message.token = String(object.token);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Session>): Session {
    const message = { ...baseSession } as Session;
    if (object.created !== undefined && object.created !== null) {
      message.created = object.created;
    }
    if (object.token !== undefined && object.token !== null) {
      message.token = object.token;
    }
    return message;
  },
  toJSON(message: Session): unknown {
    const obj: any = {};
    obj.created = message.created || false;
    obj.token = message.token || "";
    return obj;
  },
};

export const StorageObject = {
  encode(message: StorageObject, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.collection);
    writer.uint32(18).string(message.key);
    writer.uint32(26).string(message.user_id);
    writer.uint32(34).string(message.value);
    writer.uint32(42).string(message.version);
    writer.uint32(48).int32(message.permission_read);
    writer.uint32(56).int32(message.permission_write);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(66).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): StorageObject {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseStorageObject } as StorageObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.user_id = reader.string();
          break;
        case 4:
          message.value = reader.string();
          break;
        case 5:
          message.version = reader.string();
          break;
        case 6:
          message.permission_read = reader.int32();
          break;
        case 7:
          message.permission_write = reader.int32();
          break;
        case 8:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 9:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): StorageObject {
    const message = { ...baseStorageObject } as StorageObject;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = String(object.user_id);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = String(object.version);
    }
    if (object.permission_read !== undefined && object.permission_read !== null) {
      message.permission_read = Number(object.permission_read);
    }
    if (object.permission_write !== undefined && object.permission_write !== null) {
      message.permission_write = Number(object.permission_write);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    return message;
  },
  fromPartial(object: DeepPartial<StorageObject>): StorageObject {
    const message = { ...baseStorageObject } as StorageObject;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = object.user_id;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = object.version;
    }
    if (object.permission_read !== undefined && object.permission_read !== null) {
      message.permission_read = object.permission_read;
    }
    if (object.permission_write !== undefined && object.permission_write !== null) {
      message.permission_write = object.permission_write;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    return message;
  },
  toJSON(message: StorageObject): unknown {
    const obj: any = {};
    obj.collection = message.collection || "";
    obj.key = message.key || "";
    obj.user_id = message.user_id || "";
    obj.value = message.value || "";
    obj.version = message.version || "";
    obj.permission_read = message.permission_read || 0;
    obj.permission_write = message.permission_write || 0;
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    return obj;
  },
};

export const StorageObjectAck = {
  encode(message: StorageObjectAck, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.collection);
    writer.uint32(18).string(message.key);
    writer.uint32(26).string(message.version);
    writer.uint32(34).string(message.user_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): StorageObjectAck {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseStorageObjectAck } as StorageObjectAck;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.version = reader.string();
          break;
        case 4:
          message.user_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): StorageObjectAck {
    const message = { ...baseStorageObjectAck } as StorageObjectAck;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = String(object.version);
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = String(object.user_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<StorageObjectAck>): StorageObjectAck {
    const message = { ...baseStorageObjectAck } as StorageObjectAck;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = object.version;
    }
    if (object.user_id !== undefined && object.user_id !== null) {
      message.user_id = object.user_id;
    }
    return message;
  },
  toJSON(message: StorageObjectAck): unknown {
    const obj: any = {};
    obj.collection = message.collection || "";
    obj.key = message.key || "";
    obj.version = message.version || "";
    obj.user_id = message.user_id || "";
    return obj;
  },
};

export const StorageObjectAcks = {
  encode(message: StorageObjectAcks, writer: Writer = Writer.create()): Writer {
    for (const v of message.acks) {
      StorageObjectAck.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): StorageObjectAcks {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseStorageObjectAcks } as StorageObjectAcks;
    message.acks = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.acks.push(StorageObjectAck.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): StorageObjectAcks {
    const message = { ...baseStorageObjectAcks } as StorageObjectAcks;
    message.acks = [];
    if (object.acks !== undefined && object.acks !== null) {
      for (const e of object.acks) {
        message.acks.push(StorageObjectAck.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<StorageObjectAcks>): StorageObjectAcks {
    const message = { ...baseStorageObjectAcks } as StorageObjectAcks;
    message.acks = [];
    if (object.acks !== undefined && object.acks !== null) {
      for (const e of object.acks) {
        message.acks.push(StorageObjectAck.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: StorageObjectAcks): unknown {
    const obj: any = {};
    if (message.acks) {
      obj.acks = message.acks.map(e => e ? StorageObjectAck.toJSON(e) : undefined);
    } else {
      obj.acks = [];
    }
    return obj;
  },
};

export const StorageObjects = {
  encode(message: StorageObjects, writer: Writer = Writer.create()): Writer {
    for (const v of message.objects) {
      StorageObject.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): StorageObjects {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseStorageObjects } as StorageObjects;
    message.objects = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objects.push(StorageObject.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): StorageObjects {
    const message = { ...baseStorageObjects } as StorageObjects;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(StorageObject.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<StorageObjects>): StorageObjects {
    const message = { ...baseStorageObjects } as StorageObjects;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(StorageObject.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: StorageObjects): unknown {
    const obj: any = {};
    if (message.objects) {
      obj.objects = message.objects.map(e => e ? StorageObject.toJSON(e) : undefined);
    } else {
      obj.objects = [];
    }
    return obj;
  },
};

export const StorageObjectList = {
  encode(message: StorageObjectList, writer: Writer = Writer.create()): Writer {
    for (const v of message.objects) {
      StorageObject.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): StorageObjectList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseStorageObjectList } as StorageObjectList;
    message.objects = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objects.push(StorageObject.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): StorageObjectList {
    const message = { ...baseStorageObjectList } as StorageObjectList;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(StorageObject.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<StorageObjectList>): StorageObjectList {
    const message = { ...baseStorageObjectList } as StorageObjectList;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(StorageObject.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: StorageObjectList): unknown {
    const obj: any = {};
    if (message.objects) {
      obj.objects = message.objects.map(e => e ? StorageObject.toJSON(e) : undefined);
    } else {
      obj.objects = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const Tournament = {
  encode(message: Tournament, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    writer.uint32(18).string(message.title);
    writer.uint32(26).string(message.description);
    writer.uint32(32).uint32(message.category);
    writer.uint32(40).uint32(message.sort_order);
    writer.uint32(48).uint32(message.size);
    writer.uint32(56).uint32(message.max_size);
    writer.uint32(64).uint32(message.max_num_score);
    writer.uint32(72).bool(message.can_enter);
    writer.uint32(80).uint32(message.end_active);
    writer.uint32(88).uint32(message.next_reset);
    writer.uint32(98).string(message.metadata);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(106).fork()).ldelim();
    }
    if (message.start_time !== undefined && message.start_time !== undefined) {
      Timestamp.encode(toTimestamp(message.start_time), writer.uint32(114).fork()).ldelim();
    }
    if (message.end_time !== undefined && message.end_time !== undefined) {
      Timestamp.encode(toTimestamp(message.end_time), writer.uint32(122).fork()).ldelim();
    }
    writer.uint32(128).uint32(message.duration);
    writer.uint32(136).uint32(message.start_active);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Tournament {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTournament } as Tournament;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.title = reader.string();
          break;
        case 3:
          message.description = reader.string();
          break;
        case 4:
          message.category = reader.uint32();
          break;
        case 5:
          message.sort_order = reader.uint32();
          break;
        case 6:
          message.size = reader.uint32();
          break;
        case 7:
          message.max_size = reader.uint32();
          break;
        case 8:
          message.max_num_score = reader.uint32();
          break;
        case 9:
          message.can_enter = reader.bool();
          break;
        case 10:
          message.end_active = reader.uint32();
          break;
        case 11:
          message.next_reset = reader.uint32();
          break;
        case 12:
          message.metadata = reader.string();
          break;
        case 13:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 14:
          message.start_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 15:
          message.end_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 16:
          message.duration = reader.uint32();
          break;
        case 17:
          message.start_active = reader.uint32();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Tournament {
    const message = { ...baseTournament } as Tournament;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.title !== undefined && object.title !== null) {
      message.title = String(object.title);
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = String(object.description);
    }
    if (object.category !== undefined && object.category !== null) {
      message.category = Number(object.category);
    }
    if (object.sort_order !== undefined && object.sort_order !== null) {
      message.sort_order = Number(object.sort_order);
    }
    if (object.size !== undefined && object.size !== null) {
      message.size = Number(object.size);
    }
    if (object.max_size !== undefined && object.max_size !== null) {
      message.max_size = Number(object.max_size);
    }
    if (object.max_num_score !== undefined && object.max_num_score !== null) {
      message.max_num_score = Number(object.max_num_score);
    }
    if (object.can_enter !== undefined && object.can_enter !== null) {
      message.can_enter = Boolean(object.can_enter);
    }
    if (object.end_active !== undefined && object.end_active !== null) {
      message.end_active = Number(object.end_active);
    }
    if (object.next_reset !== undefined && object.next_reset !== null) {
      message.next_reset = Number(object.next_reset);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.start_time !== undefined && object.start_time !== null) {
      message.start_time = fromJsonTimestamp(object.start_time);
    }
    if (object.end_time !== undefined && object.end_time !== null) {
      message.end_time = fromJsonTimestamp(object.end_time);
    }
    if (object.duration !== undefined && object.duration !== null) {
      message.duration = Number(object.duration);
    }
    if (object.start_active !== undefined && object.start_active !== null) {
      message.start_active = Number(object.start_active);
    }
    return message;
  },
  fromPartial(object: DeepPartial<Tournament>): Tournament {
    const message = { ...baseTournament } as Tournament;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.title !== undefined && object.title !== null) {
      message.title = object.title;
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = object.description;
    }
    if (object.category !== undefined && object.category !== null) {
      message.category = object.category;
    }
    if (object.sort_order !== undefined && object.sort_order !== null) {
      message.sort_order = object.sort_order;
    }
    if (object.size !== undefined && object.size !== null) {
      message.size = object.size;
    }
    if (object.max_size !== undefined && object.max_size !== null) {
      message.max_size = object.max_size;
    }
    if (object.max_num_score !== undefined && object.max_num_score !== null) {
      message.max_num_score = object.max_num_score;
    }
    if (object.can_enter !== undefined && object.can_enter !== null) {
      message.can_enter = object.can_enter;
    }
    if (object.end_active !== undefined && object.end_active !== null) {
      message.end_active = object.end_active;
    }
    if (object.next_reset !== undefined && object.next_reset !== null) {
      message.next_reset = object.next_reset;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.start_time !== undefined && object.start_time !== null) {
      message.start_time = object.start_time;
    }
    if (object.end_time !== undefined && object.end_time !== null) {
      message.end_time = object.end_time;
    }
    if (object.duration !== undefined && object.duration !== null) {
      message.duration = object.duration;
    }
    if (object.start_active !== undefined && object.start_active !== null) {
      message.start_active = object.start_active;
    }
    return message;
  },
  toJSON(message: Tournament): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.title = message.title || "";
    obj.description = message.description || "";
    obj.category = message.category || 0;
    obj.sort_order = message.sort_order || 0;
    obj.size = message.size || 0;
    obj.max_size = message.max_size || 0;
    obj.max_num_score = message.max_num_score || 0;
    obj.can_enter = message.can_enter || false;
    obj.end_active = message.end_active || 0;
    obj.next_reset = message.next_reset || 0;
    obj.metadata = message.metadata || "";
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.start_time = message.start_time !== undefined ? message.start_time.toISOString() : null;
    obj.end_time = message.end_time !== undefined ? message.end_time.toISOString() : null;
    obj.duration = message.duration || 0;
    obj.start_active = message.start_active || 0;
    return obj;
  },
};

export const TournamentList = {
  encode(message: TournamentList, writer: Writer = Writer.create()): Writer {
    for (const v of message.tournaments) {
      Tournament.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): TournamentList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTournamentList } as TournamentList;
    message.tournaments = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tournaments.push(Tournament.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): TournamentList {
    const message = { ...baseTournamentList } as TournamentList;
    message.tournaments = [];
    if (object.tournaments !== undefined && object.tournaments !== null) {
      for (const e of object.tournaments) {
        message.tournaments.push(Tournament.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<TournamentList>): TournamentList {
    const message = { ...baseTournamentList } as TournamentList;
    message.tournaments = [];
    if (object.tournaments !== undefined && object.tournaments !== null) {
      for (const e of object.tournaments) {
        message.tournaments.push(Tournament.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: TournamentList): unknown {
    const obj: any = {};
    if (message.tournaments) {
      obj.tournaments = message.tournaments.map(e => e ? Tournament.toJSON(e) : undefined);
    } else {
      obj.tournaments = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const TournamentRecordList = {
  encode(message: TournamentRecordList, writer: Writer = Writer.create()): Writer {
    for (const v of message.records) {
      LeaderboardRecord.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.owner_records) {
      LeaderboardRecord.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    writer.uint32(26).string(message.next_cursor);
    writer.uint32(34).string(message.prev_cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): TournamentRecordList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseTournamentRecordList } as TournamentRecordList;
    message.records = [];
    message.owner_records = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.records.push(LeaderboardRecord.decode(reader, reader.uint32()));
          break;
        case 2:
          message.owner_records.push(LeaderboardRecord.decode(reader, reader.uint32()));
          break;
        case 3:
          message.next_cursor = reader.string();
          break;
        case 4:
          message.prev_cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): TournamentRecordList {
    const message = { ...baseTournamentRecordList } as TournamentRecordList;
    message.records = [];
    message.owner_records = [];
    if (object.records !== undefined && object.records !== null) {
      for (const e of object.records) {
        message.records.push(LeaderboardRecord.fromJSON(e));
      }
    }
    if (object.owner_records !== undefined && object.owner_records !== null) {
      for (const e of object.owner_records) {
        message.owner_records.push(LeaderboardRecord.fromJSON(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = String(object.next_cursor);
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = String(object.prev_cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<TournamentRecordList>): TournamentRecordList {
    const message = { ...baseTournamentRecordList } as TournamentRecordList;
    message.records = [];
    message.owner_records = [];
    if (object.records !== undefined && object.records !== null) {
      for (const e of object.records) {
        message.records.push(LeaderboardRecord.fromPartial(e));
      }
    }
    if (object.owner_records !== undefined && object.owner_records !== null) {
      for (const e of object.owner_records) {
        message.owner_records.push(LeaderboardRecord.fromPartial(e));
      }
    }
    if (object.next_cursor !== undefined && object.next_cursor !== null) {
      message.next_cursor = object.next_cursor;
    }
    if (object.prev_cursor !== undefined && object.prev_cursor !== null) {
      message.prev_cursor = object.prev_cursor;
    }
    return message;
  },
  toJSON(message: TournamentRecordList): unknown {
    const obj: any = {};
    if (message.records) {
      obj.records = message.records.map(e => e ? LeaderboardRecord.toJSON(e) : undefined);
    } else {
      obj.records = [];
    }
    if (message.owner_records) {
      obj.owner_records = message.owner_records.map(e => e ? LeaderboardRecord.toJSON(e) : undefined);
    } else {
      obj.owner_records = [];
    }
    obj.next_cursor = message.next_cursor || "";
    obj.prev_cursor = message.prev_cursor || "";
    return obj;
  },
};

export const UpdateAccountRequest = {
  encode(message: UpdateAccountRequest, writer: Writer = Writer.create()): Writer {
    if (message.username !== undefined && message.username !== undefined) {
      StringValue.encode({ value: message.username! }, writer.uint32(10).fork()).ldelim();
    }
    if (message.display_name !== undefined && message.display_name !== undefined) {
      StringValue.encode({ value: message.display_name! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.avatar_url !== undefined && message.avatar_url !== undefined) {
      StringValue.encode({ value: message.avatar_url! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lang_tag !== undefined && message.lang_tag !== undefined) {
      StringValue.encode({ value: message.lang_tag! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.location !== undefined && message.location !== undefined) {
      StringValue.encode({ value: message.location! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.timezone !== undefined && message.timezone !== undefined) {
      StringValue.encode({ value: message.timezone! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): UpdateAccountRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUpdateAccountRequest } as UpdateAccountRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.username = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 2:
          message.display_name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.avatar_url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.lang_tag = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.location = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.timezone = StringValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): UpdateAccountRequest {
    const message = { ...baseUpdateAccountRequest } as UpdateAccountRequest;
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    if (object.display_name !== undefined && object.display_name !== null) {
      message.display_name = String(object.display_name);
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = String(object.avatar_url);
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = String(object.lang_tag);
    }
    if (object.location !== undefined && object.location !== null) {
      message.location = String(object.location);
    }
    if (object.timezone !== undefined && object.timezone !== null) {
      message.timezone = String(object.timezone);
    }
    return message;
  },
  fromPartial(object: DeepPartial<UpdateAccountRequest>): UpdateAccountRequest {
    const message = { ...baseUpdateAccountRequest } as UpdateAccountRequest;
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    if (object.display_name !== undefined && object.display_name !== null) {
      message.display_name = object.display_name;
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = object.avatar_url;
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = object.lang_tag;
    }
    if (object.location !== undefined && object.location !== null) {
      message.location = object.location;
    }
    if (object.timezone !== undefined && object.timezone !== null) {
      message.timezone = object.timezone;
    }
    return message;
  },
  toJSON(message: UpdateAccountRequest): unknown {
    const obj: any = {};
    obj.username = message.username || undefined;
    obj.display_name = message.display_name || undefined;
    obj.avatar_url = message.avatar_url || undefined;
    obj.lang_tag = message.lang_tag || undefined;
    obj.location = message.location || undefined;
    obj.timezone = message.timezone || undefined;
    return obj;
  },
};

export const UpdateGroupRequest = {
  encode(message: UpdateGroupRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.group_id);
    if (message.name !== undefined && message.name !== undefined) {
      StringValue.encode({ value: message.name! }, writer.uint32(18).fork()).ldelim();
    }
    if (message.description !== undefined && message.description !== undefined) {
      StringValue.encode({ value: message.description! }, writer.uint32(26).fork()).ldelim();
    }
    if (message.lang_tag !== undefined && message.lang_tag !== undefined) {
      StringValue.encode({ value: message.lang_tag! }, writer.uint32(34).fork()).ldelim();
    }
    if (message.avatar_url !== undefined && message.avatar_url !== undefined) {
      StringValue.encode({ value: message.avatar_url! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.open !== undefined && message.open !== undefined) {
      BoolValue.encode({ value: message.open! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): UpdateGroupRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUpdateGroupRequest } as UpdateGroupRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group_id = reader.string();
          break;
        case 2:
          message.name = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 3:
          message.description = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 4:
          message.lang_tag = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 5:
          message.avatar_url = StringValue.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.open = BoolValue.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): UpdateGroupRequest {
    const message = { ...baseUpdateGroupRequest } as UpdateGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = String(object.group_id);
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = String(object.name);
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = String(object.description);
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = String(object.lang_tag);
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = String(object.avatar_url);
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = Boolean(object.open);
    }
    return message;
  },
  fromPartial(object: DeepPartial<UpdateGroupRequest>): UpdateGroupRequest {
    const message = { ...baseUpdateGroupRequest } as UpdateGroupRequest;
    if (object.group_id !== undefined && object.group_id !== null) {
      message.group_id = object.group_id;
    }
    if (object.name !== undefined && object.name !== null) {
      message.name = object.name;
    }
    if (object.description !== undefined && object.description !== null) {
      message.description = object.description;
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = object.lang_tag;
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = object.avatar_url;
    }
    if (object.open !== undefined && object.open !== null) {
      message.open = object.open;
    }
    return message;
  },
  toJSON(message: UpdateGroupRequest): unknown {
    const obj: any = {};
    obj.group_id = message.group_id || "";
    obj.name = message.name || undefined;
    obj.description = message.description || undefined;
    obj.lang_tag = message.lang_tag || undefined;
    obj.avatar_url = message.avatar_url || undefined;
    obj.open = message.open || undefined;
    return obj;
  },
};

export const User = {
  encode(message: User, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.id);
    writer.uint32(18).string(message.username);
    writer.uint32(26).string(message.display_name);
    writer.uint32(34).string(message.avatar_url);
    writer.uint32(42).string(message.lang_tag);
    writer.uint32(50).string(message.location);
    writer.uint32(58).string(message.timezone);
    writer.uint32(66).string(message.metadata);
    writer.uint32(74).string(message.facebook_id);
    writer.uint32(82).string(message.google_id);
    writer.uint32(90).string(message.gamecenter_id);
    writer.uint32(98).string(message.steam_id);
    writer.uint32(104).bool(message.online);
    writer.uint32(112).int32(message.edge_count);
    if (message.create_time !== undefined && message.create_time !== undefined) {
      Timestamp.encode(toTimestamp(message.create_time), writer.uint32(122).fork()).ldelim();
    }
    if (message.update_time !== undefined && message.update_time !== undefined) {
      Timestamp.encode(toTimestamp(message.update_time), writer.uint32(130).fork()).ldelim();
    }
    writer.uint32(138).string(message.facebook_instant_game_id);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): User {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUser } as User;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.id = reader.string();
          break;
        case 2:
          message.username = reader.string();
          break;
        case 3:
          message.display_name = reader.string();
          break;
        case 4:
          message.avatar_url = reader.string();
          break;
        case 5:
          message.lang_tag = reader.string();
          break;
        case 6:
          message.location = reader.string();
          break;
        case 7:
          message.timezone = reader.string();
          break;
        case 8:
          message.metadata = reader.string();
          break;
        case 9:
          message.facebook_id = reader.string();
          break;
        case 10:
          message.google_id = reader.string();
          break;
        case 11:
          message.gamecenter_id = reader.string();
          break;
        case 12:
          message.steam_id = reader.string();
          break;
        case 13:
          message.online = reader.bool();
          break;
        case 14:
          message.edge_count = reader.int32();
          break;
        case 15:
          message.create_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 16:
          message.update_time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          break;
        case 17:
          message.facebook_instant_game_id = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): User {
    const message = { ...baseUser } as User;
    if (object.id !== undefined && object.id !== null) {
      message.id = String(object.id);
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = String(object.username);
    }
    if (object.display_name !== undefined && object.display_name !== null) {
      message.display_name = String(object.display_name);
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = String(object.avatar_url);
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = String(object.lang_tag);
    }
    if (object.location !== undefined && object.location !== null) {
      message.location = String(object.location);
    }
    if (object.timezone !== undefined && object.timezone !== null) {
      message.timezone = String(object.timezone);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    if (object.facebook_id !== undefined && object.facebook_id !== null) {
      message.facebook_id = String(object.facebook_id);
    }
    if (object.google_id !== undefined && object.google_id !== null) {
      message.google_id = String(object.google_id);
    }
    if (object.gamecenter_id !== undefined && object.gamecenter_id !== null) {
      message.gamecenter_id = String(object.gamecenter_id);
    }
    if (object.steam_id !== undefined && object.steam_id !== null) {
      message.steam_id = String(object.steam_id);
    }
    if (object.online !== undefined && object.online !== null) {
      message.online = Boolean(object.online);
    }
    if (object.edge_count !== undefined && object.edge_count !== null) {
      message.edge_count = Number(object.edge_count);
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = fromJsonTimestamp(object.create_time);
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = fromJsonTimestamp(object.update_time);
    }
    if (object.facebook_instant_game_id !== undefined && object.facebook_instant_game_id !== null) {
      message.facebook_instant_game_id = String(object.facebook_instant_game_id);
    }
    return message;
  },
  fromPartial(object: DeepPartial<User>): User {
    const message = { ...baseUser } as User;
    if (object.id !== undefined && object.id !== null) {
      message.id = object.id;
    }
    if (object.username !== undefined && object.username !== null) {
      message.username = object.username;
    }
    if (object.display_name !== undefined && object.display_name !== null) {
      message.display_name = object.display_name;
    }
    if (object.avatar_url !== undefined && object.avatar_url !== null) {
      message.avatar_url = object.avatar_url;
    }
    if (object.lang_tag !== undefined && object.lang_tag !== null) {
      message.lang_tag = object.lang_tag;
    }
    if (object.location !== undefined && object.location !== null) {
      message.location = object.location;
    }
    if (object.timezone !== undefined && object.timezone !== null) {
      message.timezone = object.timezone;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    if (object.facebook_id !== undefined && object.facebook_id !== null) {
      message.facebook_id = object.facebook_id;
    }
    if (object.google_id !== undefined && object.google_id !== null) {
      message.google_id = object.google_id;
    }
    if (object.gamecenter_id !== undefined && object.gamecenter_id !== null) {
      message.gamecenter_id = object.gamecenter_id;
    }
    if (object.steam_id !== undefined && object.steam_id !== null) {
      message.steam_id = object.steam_id;
    }
    if (object.online !== undefined && object.online !== null) {
      message.online = object.online;
    }
    if (object.edge_count !== undefined && object.edge_count !== null) {
      message.edge_count = object.edge_count;
    }
    if (object.create_time !== undefined && object.create_time !== null) {
      message.create_time = object.create_time;
    }
    if (object.update_time !== undefined && object.update_time !== null) {
      message.update_time = object.update_time;
    }
    if (object.facebook_instant_game_id !== undefined && object.facebook_instant_game_id !== null) {
      message.facebook_instant_game_id = object.facebook_instant_game_id;
    }
    return message;
  },
  toJSON(message: User): unknown {
    const obj: any = {};
    obj.id = message.id || "";
    obj.username = message.username || "";
    obj.display_name = message.display_name || "";
    obj.avatar_url = message.avatar_url || "";
    obj.lang_tag = message.lang_tag || "";
    obj.location = message.location || "";
    obj.timezone = message.timezone || "";
    obj.metadata = message.metadata || "";
    obj.facebook_id = message.facebook_id || "";
    obj.google_id = message.google_id || "";
    obj.gamecenter_id = message.gamecenter_id || "";
    obj.steam_id = message.steam_id || "";
    obj.online = message.online || false;
    obj.edge_count = message.edge_count || 0;
    obj.create_time = message.create_time !== undefined ? message.create_time.toISOString() : null;
    obj.update_time = message.update_time !== undefined ? message.update_time.toISOString() : null;
    obj.facebook_instant_game_id = message.facebook_instant_game_id || "";
    return obj;
  },
};

export const UserGroupList = {
  encode(message: UserGroupList, writer: Writer = Writer.create()): Writer {
    for (const v of message.user_groups) {
      UserGroupList_UserGroup.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    writer.uint32(18).string(message.cursor);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): UserGroupList {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUserGroupList } as UserGroupList;
    message.user_groups = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.user_groups.push(UserGroupList_UserGroup.decode(reader, reader.uint32()));
          break;
        case 2:
          message.cursor = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): UserGroupList {
    const message = { ...baseUserGroupList } as UserGroupList;
    message.user_groups = [];
    if (object.user_groups !== undefined && object.user_groups !== null) {
      for (const e of object.user_groups) {
        message.user_groups.push(UserGroupList_UserGroup.fromJSON(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = String(object.cursor);
    }
    return message;
  },
  fromPartial(object: DeepPartial<UserGroupList>): UserGroupList {
    const message = { ...baseUserGroupList } as UserGroupList;
    message.user_groups = [];
    if (object.user_groups !== undefined && object.user_groups !== null) {
      for (const e of object.user_groups) {
        message.user_groups.push(UserGroupList_UserGroup.fromPartial(e));
      }
    }
    if (object.cursor !== undefined && object.cursor !== null) {
      message.cursor = object.cursor;
    }
    return message;
  },
  toJSON(message: UserGroupList): unknown {
    const obj: any = {};
    if (message.user_groups) {
      obj.user_groups = message.user_groups.map(e => e ? UserGroupList_UserGroup.toJSON(e) : undefined);
    } else {
      obj.user_groups = [];
    }
    obj.cursor = message.cursor || "";
    return obj;
  },
};

export const UserGroupList_UserGroup = {
  encode(message: UserGroupList_UserGroup, writer: Writer = Writer.create()): Writer {
    if (message.group !== undefined && message.group !== undefined) {
      Group.encode(message.group, writer.uint32(10).fork()).ldelim();
    }
    if (message.state !== undefined && message.state !== undefined) {
      Int32Value.encode({ value: message.state! }, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): UserGroupList_UserGroup {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUserGroupList_UserGroup } as UserGroupList_UserGroup;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.group = Group.decode(reader, reader.uint32());
          break;
        case 2:
          message.state = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): UserGroupList_UserGroup {
    const message = { ...baseUserGroupList_UserGroup } as UserGroupList_UserGroup;
    if (object.group !== undefined && object.group !== null) {
      message.group = Group.fromJSON(object.group);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = Number(object.state);
    }
    return message;
  },
  fromPartial(object: DeepPartial<UserGroupList_UserGroup>): UserGroupList_UserGroup {
    const message = { ...baseUserGroupList_UserGroup } as UserGroupList_UserGroup;
    if (object.group !== undefined && object.group !== null) {
      message.group = Group.fromPartial(object.group);
    }
    if (object.state !== undefined && object.state !== null) {
      message.state = object.state;
    }
    return message;
  },
  toJSON(message: UserGroupList_UserGroup): unknown {
    const obj: any = {};
    obj.group = message.group ? Group.toJSON(message.group) : undefined;
    obj.state = message.state || undefined;
    return obj;
  },
};

export const Users = {
  encode(message: Users, writer: Writer = Writer.create()): Writer {
    for (const v of message.users) {
      User.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): Users {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseUsers } as Users;
    message.users = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.users.push(User.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): Users {
    const message = { ...baseUsers } as Users;
    message.users = [];
    if (object.users !== undefined && object.users !== null) {
      for (const e of object.users) {
        message.users.push(User.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<Users>): Users {
    const message = { ...baseUsers } as Users;
    message.users = [];
    if (object.users !== undefined && object.users !== null) {
      for (const e of object.users) {
        message.users.push(User.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: Users): unknown {
    const obj: any = {};
    if (message.users) {
      obj.users = message.users.map(e => e ? User.toJSON(e) : undefined);
    } else {
      obj.users = [];
    }
    return obj;
  },
};

export const WriteLeaderboardRecordRequest = {
  encode(message: WriteLeaderboardRecordRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.leaderboard_id);
    if (message.record !== undefined && message.record !== undefined) {
      WriteLeaderboardRecordRequest_LeaderboardRecordWrite.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteLeaderboardRecordRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteLeaderboardRecordRequest } as WriteLeaderboardRecordRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.leaderboard_id = reader.string();
          break;
        case 2:
          message.record = WriteLeaderboardRecordRequest_LeaderboardRecordWrite.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteLeaderboardRecordRequest {
    const message = { ...baseWriteLeaderboardRecordRequest } as WriteLeaderboardRecordRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = String(object.leaderboard_id);
    }
    if (object.record !== undefined && object.record !== null) {
      message.record = WriteLeaderboardRecordRequest_LeaderboardRecordWrite.fromJSON(object.record);
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteLeaderboardRecordRequest>): WriteLeaderboardRecordRequest {
    const message = { ...baseWriteLeaderboardRecordRequest } as WriteLeaderboardRecordRequest;
    if (object.leaderboard_id !== undefined && object.leaderboard_id !== null) {
      message.leaderboard_id = object.leaderboard_id;
    }
    if (object.record !== undefined && object.record !== null) {
      message.record = WriteLeaderboardRecordRequest_LeaderboardRecordWrite.fromPartial(object.record);
    }
    return message;
  },
  toJSON(message: WriteLeaderboardRecordRequest): unknown {
    const obj: any = {};
    obj.leaderboard_id = message.leaderboard_id || "";
    obj.record = message.record ? WriteLeaderboardRecordRequest_LeaderboardRecordWrite.toJSON(message.record) : undefined;
    return obj;
  },
};

export const WriteLeaderboardRecordRequest_LeaderboardRecordWrite = {
  encode(message: WriteLeaderboardRecordRequest_LeaderboardRecordWrite, writer: Writer = Writer.create()): Writer {
    writer.uint32(8).int64(message.score);
    writer.uint32(16).int64(message.subscore);
    writer.uint32(26).string(message.metadata);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteLeaderboardRecordRequest_LeaderboardRecordWrite } as WriteLeaderboardRecordRequest_LeaderboardRecordWrite;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.score = longToNumber(reader.int64() as Long);
          break;
        case 2:
          message.subscore = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.metadata = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    const message = { ...baseWriteLeaderboardRecordRequest_LeaderboardRecordWrite } as WriteLeaderboardRecordRequest_LeaderboardRecordWrite;
    if (object.score !== undefined && object.score !== null) {
      message.score = Number(object.score);
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = Number(object.subscore);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteLeaderboardRecordRequest_LeaderboardRecordWrite>): WriteLeaderboardRecordRequest_LeaderboardRecordWrite {
    const message = { ...baseWriteLeaderboardRecordRequest_LeaderboardRecordWrite } as WriteLeaderboardRecordRequest_LeaderboardRecordWrite;
    if (object.score !== undefined && object.score !== null) {
      message.score = object.score;
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = object.subscore;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    return message;
  },
  toJSON(message: WriteLeaderboardRecordRequest_LeaderboardRecordWrite): unknown {
    const obj: any = {};
    obj.score = message.score || 0;
    obj.subscore = message.subscore || 0;
    obj.metadata = message.metadata || "";
    return obj;
  },
};

export const WriteStorageObject = {
  encode(message: WriteStorageObject, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.collection);
    writer.uint32(18).string(message.key);
    writer.uint32(26).string(message.value);
    writer.uint32(34).string(message.version);
    if (message.permission_read !== undefined && message.permission_read !== undefined) {
      Int32Value.encode({ value: message.permission_read! }, writer.uint32(42).fork()).ldelim();
    }
    if (message.permission_write !== undefined && message.permission_write !== undefined) {
      Int32Value.encode({ value: message.permission_write! }, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteStorageObject {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteStorageObject } as WriteStorageObject;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.collection = reader.string();
          break;
        case 2:
          message.key = reader.string();
          break;
        case 3:
          message.value = reader.string();
          break;
        case 4:
          message.version = reader.string();
          break;
        case 5:
          message.permission_read = Int32Value.decode(reader, reader.uint32()).value;
          break;
        case 6:
          message.permission_write = Int32Value.decode(reader, reader.uint32()).value;
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteStorageObject {
    const message = { ...baseWriteStorageObject } as WriteStorageObject;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = String(object.collection);
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = String(object.key);
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = String(object.value);
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = String(object.version);
    }
    if (object.permission_read !== undefined && object.permission_read !== null) {
      message.permission_read = Number(object.permission_read);
    }
    if (object.permission_write !== undefined && object.permission_write !== null) {
      message.permission_write = Number(object.permission_write);
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteStorageObject>): WriteStorageObject {
    const message = { ...baseWriteStorageObject } as WriteStorageObject;
    if (object.collection !== undefined && object.collection !== null) {
      message.collection = object.collection;
    }
    if (object.key !== undefined && object.key !== null) {
      message.key = object.key;
    }
    if (object.value !== undefined && object.value !== null) {
      message.value = object.value;
    }
    if (object.version !== undefined && object.version !== null) {
      message.version = object.version;
    }
    if (object.permission_read !== undefined && object.permission_read !== null) {
      message.permission_read = object.permission_read;
    }
    if (object.permission_write !== undefined && object.permission_write !== null) {
      message.permission_write = object.permission_write;
    }
    return message;
  },
  toJSON(message: WriteStorageObject): unknown {
    const obj: any = {};
    obj.collection = message.collection || "";
    obj.key = message.key || "";
    obj.value = message.value || "";
    obj.version = message.version || "";
    obj.permission_read = message.permission_read || undefined;
    obj.permission_write = message.permission_write || undefined;
    return obj;
  },
};

export const WriteStorageObjectsRequest = {
  encode(message: WriteStorageObjectsRequest, writer: Writer = Writer.create()): Writer {
    for (const v of message.objects) {
      WriteStorageObject.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteStorageObjectsRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteStorageObjectsRequest } as WriteStorageObjectsRequest;
    message.objects = [];
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.objects.push(WriteStorageObject.decode(reader, reader.uint32()));
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteStorageObjectsRequest {
    const message = { ...baseWriteStorageObjectsRequest } as WriteStorageObjectsRequest;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(WriteStorageObject.fromJSON(e));
      }
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteStorageObjectsRequest>): WriteStorageObjectsRequest {
    const message = { ...baseWriteStorageObjectsRequest } as WriteStorageObjectsRequest;
    message.objects = [];
    if (object.objects !== undefined && object.objects !== null) {
      for (const e of object.objects) {
        message.objects.push(WriteStorageObject.fromPartial(e));
      }
    }
    return message;
  },
  toJSON(message: WriteStorageObjectsRequest): unknown {
    const obj: any = {};
    if (message.objects) {
      obj.objects = message.objects.map(e => e ? WriteStorageObject.toJSON(e) : undefined);
    } else {
      obj.objects = [];
    }
    return obj;
  },
};

export const WriteTournamentRecordRequest = {
  encode(message: WriteTournamentRecordRequest, writer: Writer = Writer.create()): Writer {
    writer.uint32(10).string(message.tournament_id);
    if (message.record !== undefined && message.record !== undefined) {
      WriteTournamentRecordRequest_TournamentRecordWrite.encode(message.record, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteTournamentRecordRequest {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteTournamentRecordRequest } as WriteTournamentRecordRequest;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.tournament_id = reader.string();
          break;
        case 2:
          message.record = WriteTournamentRecordRequest_TournamentRecordWrite.decode(reader, reader.uint32());
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteTournamentRecordRequest {
    const message = { ...baseWriteTournamentRecordRequest } as WriteTournamentRecordRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = String(object.tournament_id);
    }
    if (object.record !== undefined && object.record !== null) {
      message.record = WriteTournamentRecordRequest_TournamentRecordWrite.fromJSON(object.record);
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteTournamentRecordRequest>): WriteTournamentRecordRequest {
    const message = { ...baseWriteTournamentRecordRequest } as WriteTournamentRecordRequest;
    if (object.tournament_id !== undefined && object.tournament_id !== null) {
      message.tournament_id = object.tournament_id;
    }
    if (object.record !== undefined && object.record !== null) {
      message.record = WriteTournamentRecordRequest_TournamentRecordWrite.fromPartial(object.record);
    }
    return message;
  },
  toJSON(message: WriteTournamentRecordRequest): unknown {
    const obj: any = {};
    obj.tournament_id = message.tournament_id || "";
    obj.record = message.record ? WriteTournamentRecordRequest_TournamentRecordWrite.toJSON(message.record) : undefined;
    return obj;
  },
};

export const WriteTournamentRecordRequest_TournamentRecordWrite = {
  encode(message: WriteTournamentRecordRequest_TournamentRecordWrite, writer: Writer = Writer.create()): Writer {
    writer.uint32(8).int64(message.score);
    writer.uint32(16).int64(message.subscore);
    writer.uint32(26).string(message.metadata);
    return writer;
  },
  decode(input: Uint8Array | Reader, length?: number): WriteTournamentRecordRequest_TournamentRecordWrite {
    const reader = input instanceof Uint8Array ? new Reader(input) : input;
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = { ...baseWriteTournamentRecordRequest_TournamentRecordWrite } as WriteTournamentRecordRequest_TournamentRecordWrite;
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          message.score = longToNumber(reader.int64() as Long);
          break;
        case 2:
          message.subscore = longToNumber(reader.int64() as Long);
          break;
        case 3:
          message.metadata = reader.string();
          break;
        default:
          reader.skipType(tag & 7);
          break;
      }
    }
    return message;
  },
  fromJSON(object: any): WriteTournamentRecordRequest_TournamentRecordWrite {
    const message = { ...baseWriteTournamentRecordRequest_TournamentRecordWrite } as WriteTournamentRecordRequest_TournamentRecordWrite;
    if (object.score !== undefined && object.score !== null) {
      message.score = Number(object.score);
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = Number(object.subscore);
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = String(object.metadata);
    }
    return message;
  },
  fromPartial(object: DeepPartial<WriteTournamentRecordRequest_TournamentRecordWrite>): WriteTournamentRecordRequest_TournamentRecordWrite {
    const message = { ...baseWriteTournamentRecordRequest_TournamentRecordWrite } as WriteTournamentRecordRequest_TournamentRecordWrite;
    if (object.score !== undefined && object.score !== null) {
      message.score = object.score;
    }
    if (object.subscore !== undefined && object.subscore !== null) {
      message.subscore = object.subscore;
    }
    if (object.metadata !== undefined && object.metadata !== null) {
      message.metadata = object.metadata;
    }
    return message;
  },
  toJSON(message: WriteTournamentRecordRequest_TournamentRecordWrite): unknown {
    const obj: any = {};
    obj.score = message.score || 0;
    obj.subscore = message.subscore || 0;
    obj.metadata = message.metadata || "";
    return obj;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | undefined;
type DeepPartial<T> = T extends Builtin
  ? T
  : T extends Array<infer U>
  ? Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string }
  ? { [K in keyof Omit<T, '$case'>]?: DeepPartial<T[K]> } & { $case: T['$case'] }
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;