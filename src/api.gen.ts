// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

const BASE_PATH = "http://127.0.0.1:80";

export interface ConfigurationParameters {
  basePath?: string;
  username?: string;
  password?: string;
  bearerToken?: string;
  timeoutMs?: number;
}
/** A single user-role pair. */
export interface GroupUserListGroupUser {
  // Their relationship to the group.
  state?: number;
  // User.
  user?: ApiUser;
}
/** A single group-role pair. */
export interface UserGroupListUserGroup {
  // Group.
  group?: ApiGroup;
  // The user's relationship to the group.
  state?: number;
}
/** Record values to write. */
export interface WriteLeaderboardRecordRequestLeaderboardRecordWrite {
  // Optional record metadata.
  metadata?: string;
  // The score value to submit.
  score?: string;
  // An optional secondary value.
  subscore?: string;
}
/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  // The custom id in the user's account.
  custom_id?: string;
  // The devices which belong to the user's account.
  devices?: Array<ApiAccountDevice>;
  // The email address of the user.
  email?: string;
  // The user object.
  user?: ApiUser;
  // The UNIX time when the user's email was verified.
  verify_time?: string;
  // The user's wallet data.
  wallet?: string;
}
/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface ApiAccountCustom {
  // A custom identifier.
  id?: string;
}
/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  // A device identifier. Should be obtained by a platform-specific device API.
  id?: string;
}
/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  // A valid RFC-5322 email address.
  email?: string;
  // A password for the user account.
  password?: string;
}
/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebook {
  // The OAuth token received from Facebook to access their profile API.
  token?: string;
}
/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGameCenter {
  // Bundle ID (generated by GameCenter).
  bundle_id?: string;
  // Player ID (generated by GameCenter).
  player_id?: string;
  // The URL for the public encryption key.
  public_key_url?: string;
  // A random "NSString" used to compute the hash and keep it randomized.
  salt?: string;
  // The verification signature data generated.
  signature?: string;
  // Time since UNIX epoch when the signature was created.
  timestamp_seconds?: string;
}
/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGoogle {
  // The OAuth token received from Google to access their profile API.
  token?: string;
}
/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountSteam {
  // The account token received from Steam to access their profile API.
  token?: string;
}
/** Add users to a group. */
export interface ApiAddGroupUsersRequest {
  // The group to add users to.
  group_id?: string;
  // The users to add.
  user_ids?: Array<string>;
}
/** A message sent on a channel. */
export interface ApiChannelMessage {
  // The channel this message belongs to.
  channel_id?: string;
  // The code representing a message type or category.
  code?: number;
  // The content payload.
  content?: string;
  // The UNIX time when the message was created.
  create_time?: string;
  // The unique ID of this message.
  message_id?: string;
  // True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  // Message sender, usually a user ID.
  sender_id?: string;
  // The UNIX time when the message was last updated.
  update_time?: string;
  // The username of the message sender, if any.
  username?: string;
}
/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  // A list of messages.
  messages?: Array<ApiChannelMessage>;
  // The cursor to send when retireving the next page, if any.
  next_cursor?: string;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}
/** Create a group with the current user as owner. */
export interface ApiCreateGroupRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // A description for the group.
  description?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // A unique name for the group.
  name?: string;
  // Mark a group as open or not where only admins can accept members.
  open?: boolean;
}
/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The version hash of the object.
  version?: string;
}
/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}
/** A friend of a user. */
export interface ApiFriend {
  // The friend status.
  state?: number;
  // The user object.
  user?: ApiUser;
}
/** A collection of zero or more friends of the user. */
export interface ApiFriends {
  // The Friend objects.
  friends?: Array<ApiFriend>;
}
/** A group in the server. */
export interface ApiGroup {
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time when the group was created.
  create_time?: string;
  // The id of the user who created the group.
  creator_id?: string;
  // A description for the group.
  description?: string;
  // The current count of all members in the group.
  edge_count?: number;
  // The id of a group.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The maximum number of members allowed.
  max_count?: number;
  // Additional information stored as a JSON object.
  metadata?: string;
  // The unique name of the group.
  name?: string;
  // Anyone can join open groups, otherwise only admins can accept members.
  open?: boolean;
  // The UNIX time when the group was last updated.
  update_time?: string;
}
/** A list of users belonging to a group, along with their role. */
export interface ApiGroupUserList {
  // User-role pairs for a group.
  group_users?: Array<GroupUserListGroupUser>;
}
/** Immediately join an open group, or request to join a closed one. */
export interface ApiJoinGroupRequest {
  // The group ID to join.
  group_id?: string;
}
/** Kick a set of users from a group. */
export interface ApiKickGroupUsersRequest {
  // The group ID to kick from.
  group_id?: string;
  // The users to kick.
  user_ids?: Array<string>;
}
/** Represents a complete leaderboard record with all scores and associated metadata. */
export interface ApiLeaderboardRecord {
  // The UNIX time when the leaderboard record was created.
  create_time?: string;
  // The UNIX time when the leaderboard record expires.
  expiry_time?: string;
  // The ID of the leaderboard this score belongs to.
  leaderboard_id?: string;
  // Metadata.
  metadata?: string;
  // The number of submissions to this score record.
  num_score?: number;
  // The ID of the score owner, usually a user or group.
  owner_id?: string;
  // The rank of this record.
  rank?: string;
  // The score value.
  score?: string;
  // An optional subscore value.
  subscore?: string;
  // The UNIX time when the leaderboard record was updated.
  update_time?: string;
  // The username of the score owner, if the owner is a user.
  username?: string;
}
/** A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records. */
export interface ApiLeaderboardRecordList {
  // The cursor to send when retireving the next page, if any.
  next_cursor?: string;
  // A batched set of leaderobard records belonging to specified owners.
  owner_records?: Array<ApiLeaderboardRecord>;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  // A list of leaderboard records.
  records?: Array<ApiLeaderboardRecord>;
}
/** Leave a group. */
export interface ApiLeaveGroupRequest {
  // The group ID to leave.
  group_id?: string;
}
/** Represents a realtime match. */
export interface ApiMatch {
  // True if it's an server-managed authoritative match, false otherwise.
  authoritative?: boolean;
  // Match label, if any.
  label?: string;
  // The ID of the match, can be used to join.
  match_id?: string;
  // Current number of users in the match.
  size?: number;
}
/** A list of realtime matches. */
export interface ApiMatchList {
  // A number of matches corresponding to a list operation.
  matches?: Array<ApiMatch>;
}
/** A notification in the server. */
export interface ApiNotification {
  // Category code for this notification.
  code?: number;
  // Content of the notification in JSON.
  content?: string;
  // The UNIX time when the notification was created.
  create_time?: string;
  // ID of the Notification.
  id?: string;
  // True if this notification was persisted to the database.
  persistent?: boolean;
  // ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  // Subject of the notification.
  subject?: string;
}
/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  // Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  // Collection of notifications.
  notifications?: Array<ApiNotification>;
}
/** Promote a set of users in a group to the next role up. */
export interface ApiPromoteGroupUsersRequest {
  // The group ID to promote in.
  group_id?: string;
  // The users to promote.
  user_ids?: Array<string>;
}
/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The user owner of the object.
  user_id?: string;
}
/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}
/** Execute an Lua function on the server. */
export interface ApiRpc {
  // The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  // The identifier of the function.
  id?: string;
  // The payload of the function which must be a JSON object.
  payload?: string;
}
/** A user's session used to authenticate messages. */
export interface ApiSession {
  // True if the corresponding account was just created, false otherwise.
  created?: boolean;
  // Authentication credentials.
  token?: string;
  // rUDP specific authentication credentials.
  udp_token?: string;
}
/** An object within the storage engine. */
export interface ApiStorageObject {
  // The collection which stores the object.
  collection?: string;
  // The UNIX time when the object was created.
  create_time?: string;
  // The key of the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The UNIX time when the object was last updated.
  update_time?: string;
  // The user owner of the object.
  user_id?: string;
  // The value of the object.
  value?: string;
  // The version hash of the object.
  version?: string;
}
/** A storage acknowledgement. */
export interface ApiStorageObjectAck {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The owner of the object.
  user_id?: string;
  // The version hash of the object.
  version?: string;
}
/** Batch of acknowledgements for the storage object write. */
export interface ApiStorageObjectAcks {
  // Batch of storage write acknowledgements.
  acks?: Array<ApiStorageObjectAck>;
}
/** List of storage objects. */
export interface ApiStorageObjectList {
  // The cursor associated with the query a page of results.
  cursor?: string;
  // The list of storage objects.
  objects?: Array<ApiStorageObject>;
}
/** Batch of storage objects. */
export interface ApiStorageObjects {
  // The batch of storage objects.
  objects?: Array<ApiStorageObject>;
}
/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // The display name of the user.
  display_name?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // The timezone set by the user.
  timezone?: string;
  // The username of the user's account.
  username?: string;
}
/** Update fields in a given group. */
export interface ApiUpdateGroupRequest {
  // Avatar URL.
  avatar_url?: string;
  // Description string.
  description?: string;
  // The ID of the group to update.
  group_id?: string;
  // Lang tag.
  lang_tag?: string;
  // Name.
  name?: string;
  // Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
  open?: boolean;
}
/** A user in the server. */
export interface ApiUser {
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time when the user was created.
  create_time?: string;
  // The display name of the user.
  display_name?: string;
  // Number of related edges to this user.
  edge_count?: number;
  // The Facebook id in the user's account.
  facebook_id?: string;
  // The Apple Game Center in of the user's account.
  gamecenter_id?: string;
  // The Google id in the user's account.
  google_id?: string;
  // The id of the user's account.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // Additional information stored as a JSON object.
  metadata?: string;
  // Indicates whether the user is currently online.
  online?: boolean;
  // The Steam id in the user's account.
  steam_id?: string;
  // The timezone set by the user.
  timezone?: string;
  // The UNIX time when the user was last updated.
  update_time?: string;
  // The username of the user's account.
  username?: string;
}
/** A list of groups belonging to a user, along with the user's role in each group. */
export interface ApiUserGroupList {
  // Group-role pairs for a user.
  user_groups?: Array<UserGroupListUserGroup>;
}
/** A collection of zero or more users. */
export interface ApiUsers {
  // The User objects.
  users?: Array<ApiUser>;
}
/** The object to store. */
export interface ApiWriteStorageObject {
  // The collection to store the object.
  collection?: string;
  // The key for the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The value of the object.
  value?: string;
  // The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
  version?: string;
}
/** Write objects to the storage engine. */
export interface ApiWriteStorageObjectsRequest {
  // The objects to store on the server.
  objects?: Array<ApiWriteStorageObject>;
}
/** Wrapper message for `bool`.

The JSON representation for `BoolValue` is JSON `true` and `false`. */
export interface ProtobufBoolValue {
  // The bool value.
  value?: boolean;
}
/** service Foo {
      rpc Bar(google.protobuf.Empty) returns (google.protobuf.Empty);
    }

The JSON representation for `Empty` is empty JSON object `{}`. */
export interface ProtobufEmpty {
}
/** Wrapper message for `int32`.

The JSON representation for `Int32Value` is JSON number. */
export interface ProtobufInt32Value {
  // The int32 value.
  value?: number;
}
/** Wrapper message for `string`.

The JSON representation for `StringValue` is JSON string. */
export interface ProtobufStringValue {
  // The string value.
  value?: string;
}

export const NakamaApi = (configuration: ConfigurationParameters = {
  basePath: BASE_PATH,
  bearerToken: "",
  password: "",
  username: "",
  timeoutMs: 5000,
}) => {
  return {
    /** A healthcheck which load balancers can use to check the service. */
    healthcheck(options: any = {}): Promise<ProtobufEmpty> {
      const urlPath = "/healthcheck";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Fetch the current user's account. */
    getAccount(options: any = {}): Promise<ApiAccount> {
      const urlPath = "/v2/account";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Update fields in the current user's account. */
    updateAccount(body: ApiUpdateAccountRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "PUT" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with a custom id against the server. */
    authenticateCustom(body: ApiAccountCustom, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/custom";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with a device id against the server. */
    authenticateDevice(body: ApiAccountDevice, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/device";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with an email+password against the server. */
    authenticateEmail(body: ApiAccountEmail, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/email";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with a Facebook OAuth token against the server. */
    authenticateFacebook(body: ApiAccountFacebook, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/facebook";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with Apple's GameCenter against the server. */
    authenticateGameCenter(body: ApiAccountGameCenter, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/gamecenter";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with Google against the server. */
    authenticateGoogle(body: ApiAccountGoogle, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/google";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Authenticate a user with Steam against the server. */
    authenticateSteam(body: ApiAccountSteam, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/steam";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add a custom ID to the social profiles on the current user's account. */
    linkCustom(body: ApiAccountCustom, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/custom";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add a device ID to the social profiles on the current user's account. */
    linkDevice(body: ApiAccountDevice, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/device";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add an email+password to the social profiles on the current user's account. */
    linkEmail(body: ApiAccountEmail, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/email";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add Facebook to the social profiles on the current user's account. */
    linkFacebook(body: ApiAccountFacebook, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/facebook";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add Apple's GameCenter to the social profiles on the current user's account. */
    linkGameCenter(body: ApiAccountGameCenter, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/gamecenter";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add Google to the social profiles on the current user's account. */
    linkGoogle(body: ApiAccountGoogle, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/google";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add Steam to the social profiles on the current user's account. */
    linkSteam(body: ApiAccountSteam, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/steam";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove the custom ID from the social profiles on the current user's account. */
    unlinkCustom(body: ApiAccountCustom, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/custom";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove the device ID from the social profiles on the current user's account. */
    unlinkDevice(body: ApiAccountDevice, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/device";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove the email+password from the social profiles on the current user's account. */
    unlinkEmail(body: ApiAccountEmail, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/email";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove Facebook from the social profiles on the current user's account. */
    unlinkFacebook(body: ApiAccountFacebook, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/facebook";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove Apple's GameCenter from the social profiles on the current user's account. */
    unlinkGameCenter(body: ApiAccountGameCenter, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/gamecenter";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove Google from the social profiles on the current user's account. */
    unlinkGoogle(body: ApiAccountGoogle, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/google";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Remove Steam from the social profiles on the current user's account. */
    unlinkSteam(body: ApiAccountSteam, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/steam";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List a channel's message history. */
    listChannelMessages(channelId: string, limit?: number, forward?: boolean, cursor?: string, options: any = {}): Promise<ApiChannelMessageList> {
      if (channelId === null || channelId === undefined) {
        throw new Error("'channelId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/channel/{channel_id}"
         .replace("{channel_id}", encodeURIComponent(String(channelId)));

      const queryParams = {
        limit: limit,
        forward: forward,
        cursor: cursor,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Delete one or more users by ID or username. */
    deleteFriends(options: any = {}): Promise<ProtobufEmpty> {
      const urlPath = "/v2/friend";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "DELETE" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List all friends for the current user. */
    listFriends(options: any = {}): Promise<ApiFriends> {
      const urlPath = "/v2/friend";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add friends by ID or username to a user's account. */
    addFriends(options: any = {}): Promise<ProtobufEmpty> {
      const urlPath = "/v2/friend";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Block one or more users by ID or username. */
    blockFriends(options: any = {}): Promise<ProtobufEmpty> {
      const urlPath = "/v2/friend/block";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Import Facebook friends and add them to a user's account. */
    importFacebookFriends(body: ApiAccountFacebook, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/friend/facebook";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Create a new group with the current user as the owner. */
    createGroup(body: ApiCreateGroupRequest, options: any = {}): Promise<ApiGroup> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Delete one or more groups by ID. */
    deleteGroup(groupId: string, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "DELETE" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Update fields in a given group. */
    updateGroup(groupId: string, body: ApiUpdateGroupRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "PUT" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Add users to a group. */
    addGroupUsers(groupId: string, body: ApiAddGroupUsersRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/add"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Immediately join an open group, or request to join a closed one. */
    joinGroup(groupId: string, body: ApiJoinGroupRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/join"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Kick a set of users from a group. */
    kickGroupUsers(groupId: string, body: ApiKickGroupUsersRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/kick"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Leave a group the user is a member of. */
    leaveGroup(groupId: string, body: ApiLeaveGroupRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/leave"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Promote a set of users in a group to the next role up. */
    promoteGroupUsers(groupId: string, body: ApiPromoteGroupUsersRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/promote"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List all users that are part of a group. */
    listGroupUsers(groupId: string, options: any = {}): Promise<ApiGroupUserList> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/user"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Delete a leaderboard record. */
    deleteLeaderboardRecord(leaderboardId: string, options: any = {}): Promise<ProtobufEmpty> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "DELETE" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List leaderboard records */
    listLeaderboardRecords(leaderboardId: string, ownerIds?: Array<string>, limit?: number, cursor?: string, options: any = {}): Promise<ApiLeaderboardRecordList> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
        owner_ids: ownerIds,
        limit: limit,
        cursor: cursor,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Write a record to a leaderboard. */
    writeLeaderboardRecord(leaderboardId: string, body: WriteLeaderboardRecordRequestLeaderboardRecordWrite, options: any = {}): Promise<ApiLeaderboardRecord> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Fetch list of running matches. */
    listMatches(limit?: number, authoritative?: boolean, label?: string, minSize?: number, maxSize?: number, options: any = {}): Promise<ApiMatchList> {
      const urlPath = "/v2/match";

      const queryParams = {
        limit: limit,
        authoritative: authoritative,
        label: label,
        min_size: minSize,
        max_size: maxSize,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Delete one or more users by ID or username. */
    deleteNotifications(options: any = {}): Promise<ProtobufEmpty> {
      const urlPath = "/v2/notification";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "DELETE" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Fetch list of notifications. */
    listNotifications(limit?: number, cacheableCursor?: string, options: any = {}): Promise<ApiNotificationList> {
      const urlPath = "/v2/notification";

      const queryParams = {
        limit: limit,
        cacheable_cursor: cacheableCursor,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Execute a Lua function on the server. */
    rpcFunc2(id: string, payload?: string, httpKey?: string, options: any = {}): Promise<ApiRpc> {
      if (id === null || id === undefined) {
        throw new Error("'id' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/rpc/{id}"
         .replace("{id}", encodeURIComponent(String(id)));

      const queryParams = {
        payload: payload,
        http_key: httpKey,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Execute a Lua function on the server. */
    rpcFunc(id: string, body: string, options: any = {}): Promise<ApiRpc> {
      if (id === null || id === undefined) {
        throw new Error("'id' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/rpc/{id}"
         .replace("{id}", encodeURIComponent(String(id)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Get storage objects. */
    readStorageObjects(body: ApiReadStorageObjectsRequest, options: any = {}): Promise<ApiStorageObjects> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "POST" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Write objects into the storage engine. */
    writeStorageObjects(body: ApiWriteStorageObjectsRequest, options: any = {}): Promise<ApiStorageObjectAcks> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "PUT" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Delete one or more objects by ID or username. */
    deleteStorageObjects(body: ApiDeleteStorageObjectsRequest, options: any = {}): Promise<ProtobufEmpty> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/delete";

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "PUT" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};
      fetchOptions.body = JSON.stringify(body || {});

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List publicly readable storage objects in a given collection. */
    listStorageObjects(collection: string, userId?: string, limit?: number, cursor?: string, options: any = {}): Promise<ApiStorageObjectList> {
      if (collection === null || collection === undefined) {
        throw new Error("'collection' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/{collection}"
         .replace("{collection}", encodeURIComponent(String(collection)));

      const queryParams = {
        user_id: userId,
        limit: limit,
        cursor: cursor,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List publicly readable storage objects in a given collection. */
    listStorageObjects2(collection: string, userId: string, limit?: number, cursor?: string, options: any = {}): Promise<ApiStorageObjectList> {
      if (collection === null || collection === undefined) {
        throw new Error("'collection' is a required parameter but is null or undefined.");
      }
      if (userId === null || userId === undefined) {
        throw new Error("'userId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/{collection}/{user_id}"
         .replace("{collection}", encodeURIComponent(String(collection)))
         .replace("{user_id}", encodeURIComponent(String(userId)));

      const queryParams = {
        limit: limit,
        cursor: cursor,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** Fetch zero or more users by ID and/or username. */
    getUsers(ids?: Array<string>, usernames?: Array<string>, facebookIds?: Array<string>, options: any = {}): Promise<ApiUsers> {
      const urlPath = "/v2/user";

      const queryParams = {
        ids: ids,
        usernames: usernames,
        facebook_ids: facebookIds,
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** List groups the current user belongs to. */
    listUserGroups(userId: string, options: any = {}): Promise<ApiUserGroupList> {
      if (userId === null || userId === undefined) {
        throw new Error("'userId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/user/{user_id}/group"
         .replace("{user_id}", encodeURIComponent(String(userId)));

      const queryParams = {
      } as any;
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: "GET" /*, keepalive: true */ }, ...options};
      const headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
      } as any;

      if (configuration.bearerToken) {
        headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }

      fetchOptions.headers = {...headers, ...options.headers};

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
  };
};
