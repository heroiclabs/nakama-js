// tslint:disable
/* Code generated by openapi-gen/main.go. DO NOT EDIT. */

const BASE_PATH = "http://127.0.0.1:80";

export interface ConfigurationParameters {
  basePath?: string;
  username?: string;
  password?: string;
  bearerToken?: string;
  timeoutMs?: number;
}
/** A single user-role pair. */
export interface GroupUserListGroupUser {
  // Their relationship to the group.
  state?: number;
  // User.
  user?: ApiUser;
}
/** A single group-role pair. */
export interface UserGroupListUserGroup {
  // Group.
  group?: ApiGroup;
  // The user's relationship to the group.
  state?: number;
}
/** Record values to write. */
export interface WriteLeaderboardRecordRequestLeaderboardRecordWrite {
  // Optional record metadata.
  metadata?: string;
  // The score value to submit.
  score?: string;
  // An optional secondary value.
  subscore?: string;
}
/** Record values to write. */
export interface WriteTournamentRecordRequestTournamentRecordWrite {
  // A JSON object of additional properties (optional).
  metadata?: string;
  // The score value to submit.
  score?: string;
  // An optional secondary value.
  subscore?: string;
}
/** A user with additional account details. Always the current user. */
export interface ApiAccount {
  // The custom id in the user's account.
  custom_id?: string;
  // The devices which belong to the user's account.
  devices?: Array<ApiAccountDevice>;
  // The email address of the user.
  email?: string;
  // The user object.
  user?: ApiUser;
  // The UNIX time when the user's email was verified.
  verify_time?: string;
  // The user's wallet data.
  wallet?: string;
}
/** Send a custom ID to the server. Used with authenticate/link/unlink. */
export interface ApiAccountCustom {
  // A custom identifier.
  id?: string;
}
/** Send a device to the server. Used with authenticate/link/unlink and user. */
export interface ApiAccountDevice {
  // A device identifier. Should be obtained by a platform-specific device API.
  id?: string;
}
/** Send an email with password to the server. Used with authenticate/link/unlink. */
export interface ApiAccountEmail {
  // A valid RFC-5322 email address.
  email?: string;
  // A password for the user account.
  password?: string;
}
/** Send a Facebook token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountFacebook {
  // The OAuth token received from Facebook to access their profile API.
  token?: string;
}
/** Send Apple's Game Center account credentials to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGameCenter {
  // Bundle ID (generated by GameCenter).
  bundle_id?: string;
  // Player ID (generated by GameCenter).
  player_id?: string;
  // The URL for the public encryption key.
  public_key_url?: string;
  // A random "NSString" used to compute the hash and keep it randomized.
  salt?: string;
  // The verification signature data generated.
  signature?: string;
  // Time since UNIX epoch when the signature was created.
  timestamp_seconds?: string;
}
/** Send a Google token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountGoogle {
  // The OAuth token received from Google to access their profile API.
  token?: string;
}
/** Send a Steam token to the server. Used with authenticate/link/unlink. */
export interface ApiAccountSteam {
  // The account token received from Steam to access their profile API.
  token?: string;
}
/** A message sent on a channel. */
export interface ApiChannelMessage {
  // The channel this message belongs to.
  channel_id?: string;
  // The code representing a message type or category.
  code?: number;
  // The content payload.
  content?: string;
  // The UNIX time when the message was created.
  create_time?: string;
  // The unique ID of this message.
  message_id?: string;
  // True if the message was persisted to the channel's history, false otherwise.
  persistent?: boolean;
  // Message sender, usually a user ID.
  sender_id?: string;
  // The UNIX time when the message was last updated.
  update_time?: string;
  // The username of the message sender, if any.
  username?: string;
}
/** A list of channel messages, usually a result of a list operation. */
export interface ApiChannelMessageList {
  // A list of messages.
  messages?: Array<ApiChannelMessage>;
  // The cursor to send when retireving the next page, if any.
  next_cursor?: string;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
}
/** Create a group with the current user as owner. */
export interface ApiCreateGroupRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // A description for the group.
  description?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // A unique name for the group.
  name?: string;
  // Mark a group as open or not where only admins can accept members.
  open?: boolean;
}
/** Storage objects to delete. */
export interface ApiDeleteStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The version hash of the object.
  version?: string;
}
/** Batch delete storage objects. */
export interface ApiDeleteStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiDeleteStorageObjectId>;
}
/** A friend of a user. */
export interface ApiFriend {
  // The friend status.
  state?: number;
  // The user object.
  user?: ApiUser;
}
/** A collection of zero or more friends of the user. */
export interface ApiFriends {
  // The Friend objects.
  friends?: Array<ApiFriend>;
}
/** A group in the server. */
export interface ApiGroup {
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time when the group was created.
  create_time?: string;
  // The id of the user who created the group.
  creator_id?: string;
  // A description for the group.
  description?: string;
  // The current count of all members in the group.
  edge_count?: number;
  // The id of a group.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The maximum number of members allowed.
  max_count?: number;
  // Additional information stored as a JSON object.
  metadata?: string;
  // The unique name of the group.
  name?: string;
  // Anyone can join open groups, otherwise only admins can accept members.
  open?: boolean;
  // The UNIX time when the group was last updated.
  update_time?: string;
}
/** One or more groups returned from a listing operation. */
export interface ApiGroupList {
  // A cursor used to get the next page.
  cursor?: string;
  // One or more groups.
  groups?: Array<ApiGroup>;
}
/** A list of users belonging to a group, along with their role. */
export interface ApiGroupUserList {
  // User-role pairs for a group.
  group_users?: Array<GroupUserListGroupUser>;
}
/** Represents a complete leaderboard record with all scores and associated metadata. */
export interface ApiLeaderboardRecord {
  // The UNIX time when the leaderboard record was created.
  create_time?: string;
  // The UNIX time when the leaderboard record expires.
  expiry_time?: string;
  // The ID of the leaderboard this score belongs to.
  leaderboard_id?: string;
  // The maximum number of score updates allowed by the owner.
  max_num_score?: number;
  // Metadata.
  metadata?: string;
  // The number of submissions to this score record.
  num_score?: number;
  // The ID of the score owner, usually a user or group.
  owner_id?: string;
  // The rank of this record.
  rank?: string;
  // The score value.
  score?: string;
  // An optional subscore value.
  subscore?: string;
  // The UNIX time when the leaderboard record was updated.
  update_time?: string;
  // The username of the score owner, if the owner is a user.
  username?: string;
}
/** A set of leaderboard records, may be part of a leaderboard records page or a batch of individual records. */
export interface ApiLeaderboardRecordList {
  // The cursor to send when retireving the next page, if any.
  next_cursor?: string;
  // A batched set of leaderobard records belonging to specified owners.
  owner_records?: Array<ApiLeaderboardRecord>;
  // The cursor to send when retrieving the previous page, if any.
  prev_cursor?: string;
  // A list of leaderboard records.
  records?: Array<ApiLeaderboardRecord>;
}
/** Represents a realtime match. */
export interface ApiMatch {
  // True if it's an server-managed authoritative match, false otherwise.
  authoritative?: boolean;
  // Match label, if any.
  label?: string;
  // The ID of the match, can be used to join.
  match_id?: string;
  // Current number of users in the match.
  size?: number;
}
/** A list of realtime matches. */
export interface ApiMatchList {
  // A number of matches corresponding to a list operation.
  matches?: Array<ApiMatch>;
}
/** A notification in the server. */
export interface ApiNotification {
  // Category code for this notification.
  code?: number;
  // Content of the notification in JSON.
  content?: string;
  // The UNIX time when the notification was created.
  create_time?: string;
  // ID of the Notification.
  id?: string;
  // True if this notification was persisted to the database.
  persistent?: boolean;
  // ID of the sender, if a user. Otherwise 'null'.
  sender_id?: string;
  // Subject of the notification.
  subject?: string;
}
/** A collection of zero or more notifications. */
export interface ApiNotificationList {
  // Use this cursor to paginate notifications. Cache this to catch up to new notifications.
  cacheable_cursor?: string;
  // Collection of notifications.
  notifications?: Array<ApiNotification>;
}
/** Storage objects to get. */
export interface ApiReadStorageObjectId {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The user owner of the object.
  user_id?: string;
}
/** Batch get storage objects. */
export interface ApiReadStorageObjectsRequest {
  // Batch of storage objects.
  object_ids?: Array<ApiReadStorageObjectId>;
}
/** Execute an Lua function on the server. */
export interface ApiRpc {
  // The authentication key used when executed as a non-client HTTP request.
  http_key?: string;
  // The identifier of the function.
  id?: string;
  // The payload of the function which must be a JSON object.
  payload?: string;
}
/** A user's session used to authenticate messages. */
export interface ApiSession {
  // True if the corresponding account was just created, false otherwise.
  created?: boolean;
  // Authentication credentials.
  token?: string;
  // rUDP specific authentication credentials.
  udp_token?: string;
}
/** An object within the storage engine. */
export interface ApiStorageObject {
  // The collection which stores the object.
  collection?: string;
  // The UNIX time when the object was created.
  create_time?: string;
  // The key of the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The UNIX time when the object was last updated.
  update_time?: string;
  // The user owner of the object.
  user_id?: string;
  // The value of the object.
  value?: string;
  // The version hash of the object.
  version?: string;
}
/** A storage acknowledgement. */
export interface ApiStorageObjectAck {
  // The collection which stores the object.
  collection?: string;
  // The key of the object within the collection.
  key?: string;
  // The owner of the object.
  user_id?: string;
  // The version hash of the object.
  version?: string;
}
/** Batch of acknowledgements for the storage object write. */
export interface ApiStorageObjectAcks {
  // Batch of storage write acknowledgements.
  acks?: Array<ApiStorageObjectAck>;
}
/** List of storage objects. */
export interface ApiStorageObjectList {
  // The cursor associated with the query a page of results.
  cursor?: string;
  // The list of storage objects.
  objects?: Array<ApiStorageObject>;
}
/** Batch of storage objects. */
export interface ApiStorageObjects {
  // The batch of storage objects.
  objects?: Array<ApiStorageObject>;
}
/** A tournament on the server. */
export interface ApiTournament {
  // True if the tournament is active and can enter. A computed value.
  can_enter?: boolean;
  // The category of the tournament. e.g. "vip" could be category 1.
  category?: number;
  // The UNIX time when the tournament was created.
  create_time?: string;
  // The description of the tournament. May be blank.
  description?: string;
  // The UNIX timestamp for duration of a tournament.
  duration?: number;
  // The UNIX timestamp when the tournament stops being active until next reset. A computed value.
  end_active?: number;
  // The UNIX time when the tournament will be stopped.
  end_time?: string;
  // The ID of the tournament.
  id?: string;
  // The maximum score updates allowed per player for the current tournament.
  max_num_score?: number;
  // The maximum number of players for the tournament.
  max_size?: number;
  // Additional information stored as a JSON object.
  metadata?: string;
  // The UNIX timestamp when the tournament is next playable. A computed value.
  next_reset?: number;
  // The current number of players in the tournament.
  size?: number;
  // ASC or DESC sort mode of scores in the tournament.
  sort_order?: number;
  // The UNIX time when the tournament will start.
  start_time?: string;
  // The title for the tournament.
  title?: string;
}
/** A list of tournaments. */
export interface ApiTournamentList {
  // A pagination cursor (optional).
  cursor?: string;
  // The list of tournaments returned.
  tournaments?: Array<ApiTournament>;
}
/** A set of tournament records which may be part of a tournament records page or a batch of individual records. */
export interface ApiTournamentRecordList {
  // The cursor to send when retireving the next page (optional).
  next_cursor?: string;
  // A batched set of tournament records belonging to specified owners.
  owner_records?: Array<ApiLeaderboardRecord>;
  // The cursor to send when retrieving the previous page (optional).
  prev_cursor?: string;
  // A list of tournament records.
  records?: Array<ApiLeaderboardRecord>;
}
/** Update a user's account details. */
export interface ApiUpdateAccountRequest {
  // A URL for an avatar image.
  avatar_url?: string;
  // The display name of the user.
  display_name?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // The timezone set by the user.
  timezone?: string;
  // The username of the user's account.
  username?: string;
}
/** Update fields in a given group. */
export interface ApiUpdateGroupRequest {
  // Avatar URL.
  avatar_url?: string;
  // Description string.
  description?: string;
  // The ID of the group to update.
  group_id?: string;
  // Lang tag.
  lang_tag?: string;
  // Name.
  name?: string;
  // Open is true if anyone should be allowed to join, or false if joins must be approved by a group admin.
  open?: boolean;
}
/** A user in the server. */
export interface ApiUser {
  // A URL for an avatar image.
  avatar_url?: string;
  // The UNIX time when the user was created.
  create_time?: string;
  // The display name of the user.
  display_name?: string;
  // Number of related edges to this user.
  edge_count?: number;
  // The Facebook id in the user's account.
  facebook_id?: string;
  // The Apple Game Center in of the user's account.
  gamecenter_id?: string;
  // The Google id in the user's account.
  google_id?: string;
  // The id of the user's account.
  id?: string;
  // The language expected to be a tag which follows the BCP-47 spec.
  lang_tag?: string;
  // The location set by the user.
  location?: string;
  // Additional information stored as a JSON object.
  metadata?: string;
  // Indicates whether the user is currently online.
  online?: boolean;
  // The Steam id in the user's account.
  steam_id?: string;
  // The timezone set by the user.
  timezone?: string;
  // The UNIX time when the user was last updated.
  update_time?: string;
  // The username of the user's account.
  username?: string;
}
/** A list of groups belonging to a user, along with the user's role in each group. */
export interface ApiUserGroupList {
  // Group-role pairs for a user.
  user_groups?: Array<UserGroupListUserGroup>;
}
/** A collection of zero or more users. */
export interface ApiUsers {
  // The User objects.
  users?: Array<ApiUser>;
}
/** The object to store. */
export interface ApiWriteStorageObject {
  // The collection to store the object.
  collection?: string;
  // The key for the object within the collection.
  key?: string;
  // The read access permissions for the object.
  permission_read?: number;
  // The write access permissions for the object.
  permission_write?: number;
  // The value of the object.
  value?: string;
  // The version hash of the object to check. Possible values are: ["", "*", "#hash#"].
  version?: string;
}
/** Write objects to the storage engine. */
export interface ApiWriteStorageObjectsRequest {
  // The objects to store on the server.
  objects?: Array<ApiWriteStorageObject>;
}

export const NakamaApi = (configuration: ConfigurationParameters = {
  basePath: BASE_PATH,
  bearerToken: "",
  password: "",
  username: "",
  timeoutMs: 5000,
}) => {
  const napi = {
    /** Perform the underlying Fetch operation and return Promise object **/
    doFetch(urlPath: string, method: string, queryParams: any, body?: any, options?: any): Promise<any> {
      const urlQuery = "?" + Object.keys(queryParams)
        .map(k => {
          if (queryParams[k] instanceof Array) {
            return queryParams[k].reduce((prev: any, curr: any) => {
              return prev + encodeURIComponent(k) + "=" + encodeURIComponent(curr) + "&";
            }, "");
          } else {
            if (queryParams[k] != null) {
              return encodeURIComponent(k) + "=" + encodeURIComponent(queryParams[k]) + "&";
            }
          }
        })
        .join("");

      const fetchOptions = {...{ method: method /*, keepalive: true */ }, ...options};
      fetchOptions.headers = {...options.headers};
      if (configuration.bearerToken) {
        fetchOptions.headers["Authorization"] = "Bearer " + configuration.bearerToken;
      } else if (configuration.username) {
        fetchOptions.headers["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
      }
      if(!Object.keys(fetchOptions.headers).includes("Accept")) {
        fetchOptions.headers["Accept"] = "application/json";
      }
      if(!Object.keys(fetchOptions.headers).includes("Content-Type")) {
        fetchOptions.headers["Content-Type"] = "application/json";
      }
      Object.keys(fetchOptions.headers).forEach((key: string) => {
        if(!fetchOptions.headers[key]) {
          delete fetchOptions.headers[key];
        }
      });
      fetchOptions.body = body;

      return Promise.race([
        fetch(configuration.basePath + urlPath + urlQuery, fetchOptions).then((response) => {
          if (response.status == 204) {
            return response;
          } else if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        }),
        new Promise((_, reject) =>
          setTimeout(reject, configuration.timeoutMs, "Request timed out.")
        ),
      ]);
    },
    /** A healthcheck which load balancers can use to check the service. */
    healthcheck(options: any = {}): Promise<any> {
      const urlPath = "/healthcheck";

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Fetch the current user's account. */
    getAccount(options: any = {}): Promise<ApiAccount> {
      const urlPath = "/v2/account";

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Update fields in the current user's account. */
    updateAccount(body: ApiUpdateAccountRequest, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "PUT", queryParams, _body, options)
    },
    /** Authenticate a user with a custom id against the server. */
    authenticateCustom(body: ApiAccountCustom, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/custom";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with a device id against the server. */
    authenticateDevice(body: ApiAccountDevice, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/device";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with an email+password against the server. */
    authenticateEmail(body: ApiAccountEmail, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/email";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with a Facebook OAuth token against the server. */
    authenticateFacebook(body: ApiAccountFacebook, create?: boolean, username?: string, sync?: boolean, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/facebook";

      const queryParams = {
        create: create,
        username: username,
        sync: sync,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with Apple's GameCenter against the server. */
    authenticateGameCenter(body: ApiAccountGameCenter, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/gamecenter";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with Google against the server. */
    authenticateGoogle(body: ApiAccountGoogle, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/google";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Authenticate a user with Steam against the server. */
    authenticateSteam(body: ApiAccountSteam, create?: boolean, username?: string, options: any = {}): Promise<ApiSession> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/authenticate/steam";

      const queryParams = {
        create: create,
        username: username,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add a custom ID to the social profiles on the current user's account. */
    linkCustom(body: ApiAccountCustom, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/custom";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add a device ID to the social profiles on the current user's account. */
    linkDevice(body: ApiAccountDevice, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/device";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add an email+password to the social profiles on the current user's account. */
    linkEmail(body: ApiAccountEmail, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/email";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add Facebook to the social profiles on the current user's account. */
    linkFacebook(body: ApiAccountFacebook, sync?: boolean, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/facebook";

      const queryParams = {
        sync: sync,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add Apple's GameCenter to the social profiles on the current user's account. */
    linkGameCenter(body: ApiAccountGameCenter, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/gamecenter";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add Google to the social profiles on the current user's account. */
    linkGoogle(body: ApiAccountGoogle, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/google";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Add Steam to the social profiles on the current user's account. */
    linkSteam(body: ApiAccountSteam, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/link/steam";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove the custom ID from the social profiles on the current user's account. */
    unlinkCustom(body: ApiAccountCustom, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/custom";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove the device ID from the social profiles on the current user's account. */
    unlinkDevice(body: ApiAccountDevice, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/device";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove the email+password from the social profiles on the current user's account. */
    unlinkEmail(body: ApiAccountEmail, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/email";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove Facebook from the social profiles on the current user's account. */
    unlinkFacebook(body: ApiAccountFacebook, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/facebook";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove Apple's GameCenter from the social profiles on the current user's account. */
    unlinkGameCenter(body: ApiAccountGameCenter, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/gamecenter";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove Google from the social profiles on the current user's account. */
    unlinkGoogle(body: ApiAccountGoogle, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/google";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Remove Steam from the social profiles on the current user's account. */
    unlinkSteam(body: ApiAccountSteam, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/account/unlink/steam";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** List a channel's message history. */
    listChannelMessages(channelId: string, limit?: number, forward?: boolean, cursor?: string, options: any = {}): Promise<ApiChannelMessageList> {
      if (channelId === null || channelId === undefined) {
        throw new Error("'channelId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/channel/{channel_id}"
         .replace("{channel_id}", encodeURIComponent(String(channelId)));

      const queryParams = {
        limit: limit,
        forward: forward,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Delete one or more users by ID or username. */
    deleteFriends(ids?: Array<string>, usernames?: Array<string>, options: any = {}): Promise<any> {
      const urlPath = "/v2/friend";

      const queryParams = {
        ids: ids,
        usernames: usernames,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "DELETE", queryParams, _body, options)
    },
    /** List all friends for the current user. */
    listFriends(options: any = {}): Promise<ApiFriends> {
      const urlPath = "/v2/friend";

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Add friends by ID or username to a user's account. */
    addFriends(options: any = {}): Promise<any> {
      const urlPath = "/v2/friend";

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Block one or more users by ID or username. */
    blockFriends(options: any = {}): Promise<any> {
      const urlPath = "/v2/friend/block";

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Import Facebook friends and add them to a user's account. */
    importFacebookFriends(body: ApiAccountFacebook, reset?: boolean, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/friend/facebook";

      const queryParams = {
        reset: reset,
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** List groups based on given filters. */
    listGroups(name?: string, cursor?: string, limit?: number, options: any = {}): Promise<ApiGroupList> {
      const urlPath = "/v2/group";

      const queryParams = {
        name: name,
        cursor: cursor,
        limit: limit,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Create a new group with the current user as the owner. */
    createGroup(body: ApiCreateGroupRequest, options: any = {}): Promise<ApiGroup> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Delete a group by ID. */
    deleteGroup(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "DELETE", queryParams, _body, options)
    },
    /** Update fields in a given group. */
    updateGroup(groupId: string, body: ApiUpdateGroupRequest, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "PUT", queryParams, _body, options)
    },
    /** Add users to a group. */
    addGroupUsers(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/add"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Immediately join an open group, or request to join a closed one. */
    joinGroup(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/join"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Kick a set of users from a group. */
    kickGroupUsers(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/kick"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Leave a group the user is a member of. */
    leaveGroup(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/leave"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Promote a set of users in a group to the next role up. */
    promoteGroupUsers(groupId: string, options: any = {}): Promise<any> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/promote"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** List all users that are part of a group. */
    listGroupUsers(groupId: string, options: any = {}): Promise<ApiGroupUserList> {
      if (groupId === null || groupId === undefined) {
        throw new Error("'groupId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/group/{group_id}/user"
         .replace("{group_id}", encodeURIComponent(String(groupId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Delete a leaderboard record. */
    deleteLeaderboardRecord(leaderboardId: string, options: any = {}): Promise<any> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "DELETE", queryParams, _body, options)
    },
    /** List leaderboard records. */
    listLeaderboardRecords(leaderboardId: string, ownerIds?: Array<string>, limit?: number, cursor?: string, options: any = {}): Promise<ApiLeaderboardRecordList> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
        owner_ids: ownerIds,
        limit: limit,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Write a record to a leaderboard. */
    writeLeaderboardRecord(leaderboardId: string, body: WriteLeaderboardRecordRequestLeaderboardRecordWrite, options: any = {}): Promise<ApiLeaderboardRecord> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)));

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** List leaderboard records that belong to a user. */
    listLeaderboardRecordsAroundOwner(leaderboardId: string, ownerId: string, limit?: number, options: any = {}): Promise<ApiLeaderboardRecordList> {
      if (leaderboardId === null || leaderboardId === undefined) {
        throw new Error("'leaderboardId' is a required parameter but is null or undefined.");
      }
      if (ownerId === null || ownerId === undefined) {
        throw new Error("'ownerId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/leaderboard/{leaderboard_id}/owner/{owner_id}"
         .replace("{leaderboard_id}", encodeURIComponent(String(leaderboardId)))
         .replace("{owner_id}", encodeURIComponent(String(ownerId)));

      const queryParams = {
        limit: limit,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Fetch list of running matches. */
    listMatches(limit?: number, authoritative?: boolean, label?: string, minSize?: number, maxSize?: number, query?: string, options: any = {}): Promise<ApiMatchList> {
      const urlPath = "/v2/match";

      const queryParams = {
        limit: limit,
        authoritative: authoritative,
        label: label,
        min_size: minSize,
        max_size: maxSize,
        query: query,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Delete one or more notifications for the current user. */
    deleteNotifications(ids?: Array<string>, options: any = {}): Promise<any> {
      const urlPath = "/v2/notification";

      const queryParams = {
        ids: ids,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "DELETE", queryParams, _body, options)
    },
    /** Fetch list of notifications. */
    listNotifications(limit?: number, cacheableCursor?: string, options: any = {}): Promise<ApiNotificationList> {
      const urlPath = "/v2/notification";

      const queryParams = {
        limit: limit,
        cacheable_cursor: cacheableCursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Execute a Lua function on the server. */
    rpcFunc2(id: string, payload?: string, httpKey?: string, options: any = {}): Promise<ApiRpc> {
      if (id === null || id === undefined) {
        throw new Error("'id' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/rpc/{id}"
         .replace("{id}", encodeURIComponent(String(id)));

      const queryParams = {
        payload: payload,
        http_key: httpKey,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Execute a Lua function on the server. */
    rpcFunc(id: string, body: string, options: any = {}): Promise<ApiRpc> {
      if (id === null || id === undefined) {
        throw new Error("'id' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/rpc/{id}"
         .replace("{id}", encodeURIComponent(String(id)));

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Get storage objects. */
    readStorageObjects(body: ApiReadStorageObjectsRequest, options: any = {}): Promise<ApiStorageObjects> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** Write objects into the storage engine. */
    writeStorageObjects(body: ApiWriteStorageObjectsRequest, options: any = {}): Promise<ApiStorageObjectAcks> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "PUT", queryParams, _body, options)
    },
    /** Delete one or more objects by ID or username. */
    deleteStorageObjects(body: ApiDeleteStorageObjectsRequest, options: any = {}): Promise<any> {
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/delete";

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "PUT", queryParams, _body, options)
    },
    /** List publicly readable storage objects in a given collection. */
    listStorageObjects(collection: string, userId?: string, limit?: number, cursor?: string, options: any = {}): Promise<ApiStorageObjectList> {
      if (collection === null || collection === undefined) {
        throw new Error("'collection' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/{collection}"
         .replace("{collection}", encodeURIComponent(String(collection)));

      const queryParams = {
        user_id: userId,
        limit: limit,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** List publicly readable storage objects in a given collection. */
    listStorageObjects2(collection: string, userId: string, limit?: number, cursor?: string, options: any = {}): Promise<ApiStorageObjectList> {
      if (collection === null || collection === undefined) {
        throw new Error("'collection' is a required parameter but is null or undefined.");
      }
      if (userId === null || userId === undefined) {
        throw new Error("'userId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/storage/{collection}/{user_id}"
         .replace("{collection}", encodeURIComponent(String(collection)))
         .replace("{user_id}", encodeURIComponent(String(userId)));

      const queryParams = {
        limit: limit,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** List current or upcoming tournaments. */
    listTournaments(categoryStart?: number, categoryEnd?: number, startTime?: number, endTime?: number, limit?: number, cursor?: string, options: any = {}): Promise<ApiTournamentList> {
      const urlPath = "/v2/tournament";

      const queryParams = {
        category_start: categoryStart,
        category_end: categoryEnd,
        start_time: startTime,
        end_time: endTime,
        limit: limit,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** List tournament records. */
    listTournamentRecords(tournamentId: string, ownerIds?: Array<string>, limit?: number, cursor?: string, options: any = {}): Promise<ApiTournamentRecordList> {
      if (tournamentId === null || tournamentId === undefined) {
        throw new Error("'tournamentId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/tournament/{tournament_id}"
         .replace("{tournament_id}", encodeURIComponent(String(tournamentId)));

      const queryParams = {
        owner_ids: ownerIds,
        limit: limit,
        cursor: cursor,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Write a record to a tournament. */
    writeTournamentRecord(tournamentId: string, body: WriteTournamentRecordRequestTournamentRecordWrite, options: any = {}): Promise<ApiLeaderboardRecord> {
      if (tournamentId === null || tournamentId === undefined) {
        throw new Error("'tournamentId' is a required parameter but is null or undefined.");
      }
      if (body === null || body === undefined) {
        throw new Error("'body' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/tournament/{tournament_id}"
         .replace("{tournament_id}", encodeURIComponent(String(tournamentId)));

      const queryParams = {
      } as any;

      let _body = null;
      _body = JSON.stringify(body || {});

      return napi.doFetch(urlPath, "PUT", queryParams, _body, options)
    },
    /** Attempt to join an open and running tournament. */
    joinTournament(tournamentId: string, options: any = {}): Promise<any> {
      if (tournamentId === null || tournamentId === undefined) {
        throw new Error("'tournamentId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/tournament/{tournament_id}/join"
         .replace("{tournament_id}", encodeURIComponent(String(tournamentId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "POST", queryParams, _body, options)
    },
    /** List tournament records for a given owner. */
    listTournamentRecordsAroundOwner(tournamentId: string, ownerId: string, limit?: number, options: any = {}): Promise<ApiTournamentRecordList> {
      if (tournamentId === null || tournamentId === undefined) {
        throw new Error("'tournamentId' is a required parameter but is null or undefined.");
      }
      if (ownerId === null || ownerId === undefined) {
        throw new Error("'ownerId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/tournament/{tournament_id}/owner/{owner_id}"
         .replace("{tournament_id}", encodeURIComponent(String(tournamentId)))
         .replace("{owner_id}", encodeURIComponent(String(ownerId)));

      const queryParams = {
        limit: limit,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** Fetch zero or more users by ID and/or username. */
    getUsers(ids?: Array<string>, usernames?: Array<string>, facebookIds?: Array<string>, options: any = {}): Promise<ApiUsers> {
      const urlPath = "/v2/user";

      const queryParams = {
        ids: ids,
        usernames: usernames,
        facebook_ids: facebookIds,
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
    /** List groups the current user belongs to. */
    listUserGroups(userId: string, options: any = {}): Promise<ApiUserGroupList> {
      if (userId === null || userId === undefined) {
        throw new Error("'userId' is a required parameter but is null or undefined.");
      }
      const urlPath = "/v2/user/{user_id}/group"
         .replace("{user_id}", encodeURIComponent(String(userId)));

      const queryParams = {
      } as any;

      let _body = null;

      return napi.doFetch(urlPath, "GET", queryParams, _body, options)
    },
  };

  return napi;
};
